/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/csv-parse";
exports.ids = ["vendor-chunks/csv-parse"];
exports.modules = {

/***/ "(ssr)/./node_modules/csv-parse/lib/ResizeableBuffer.js":
/*!********************************************************!*\
  !*** ./node_modules/csv-parse/lib/ResizeableBuffer.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\n\nclass ResizeableBuffer{\n  constructor(size=100){\n    this.size = size\n    this.length = 0\n    this.buf = Buffer.alloc(size)\n  }\n  prepend(val){\n    if(Buffer.isBuffer(val)){\n      const length = this.length + val.length\n      if(length >= this.size){\n        this.resize()\n        if(length >= this.size){\n          throw Error('INVALID_BUFFER_STATE')\n        }\n      }\n      const buf = this.buf\n      this.buf = Buffer.alloc(this.size)\n      val.copy(this.buf, 0)\n      buf.copy(this.buf, val.length)\n      this.length += val.length\n    }else{\n      const length = this.length++\n      if(length === this.size){\n        this.resize()\n      }\n      const buf = this.clone()\n      this.buf[0] = val\n      buf.copy(this.buf,1, 0, length)\n    }\n  }\n  append(val){\n    const length = this.length++\n    if(length === this.size){\n      this.resize()\n    }\n    this.buf[length] = val\n  }\n  clone(){\n    return Buffer.from(this.buf.slice(0, this.length))\n  }\n  resize(){\n    const length = this.length\n    this.size = this.size * 2\n    const buf = Buffer.alloc(this.size)\n    this.buf.copy(buf,0, 0, length)\n    this.buf = buf\n  }\n  toString(encoding){\n    if(encoding){\n      return this.buf.slice(0, this.length).toString(encoding)\n    }else{\n      return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length))\n    }\n  }\n  toJSON(){\n    return this.toString('utf8')\n  }\n  reset(){\n    this.length = 0\n  }\n}\n\nmodule.exports = ResizeableBuffer\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3N2LXBhcnNlL2xpYi9SZXNpemVhYmxlQnVmZmVyLmpzIiwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWV0YXBsZXgtdW1pLW5leHQtanMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvY3N2LXBhcnNlL2xpYi9SZXNpemVhYmxlQnVmZmVyLmpzP2RmZjIiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbmNsYXNzIFJlc2l6ZWFibGVCdWZmZXJ7XG4gIGNvbnN0cnVjdG9yKHNpemU9MTAwKXtcbiAgICB0aGlzLnNpemUgPSBzaXplXG4gICAgdGhpcy5sZW5ndGggPSAwXG4gICAgdGhpcy5idWYgPSBCdWZmZXIuYWxsb2Moc2l6ZSlcbiAgfVxuICBwcmVwZW5kKHZhbCl7XG4gICAgaWYoQnVmZmVyLmlzQnVmZmVyKHZhbCkpe1xuICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGggKyB2YWwubGVuZ3RoXG4gICAgICBpZihsZW5ndGggPj0gdGhpcy5zaXplKXtcbiAgICAgICAgdGhpcy5yZXNpemUoKVxuICAgICAgICBpZihsZW5ndGggPj0gdGhpcy5zaXplKXtcbiAgICAgICAgICB0aHJvdyBFcnJvcignSU5WQUxJRF9CVUZGRVJfU1RBVEUnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBidWYgPSB0aGlzLmJ1ZlxuICAgICAgdGhpcy5idWYgPSBCdWZmZXIuYWxsb2ModGhpcy5zaXplKVxuICAgICAgdmFsLmNvcHkodGhpcy5idWYsIDApXG4gICAgICBidWYuY29weSh0aGlzLmJ1ZiwgdmFsLmxlbmd0aClcbiAgICAgIHRoaXMubGVuZ3RoICs9IHZhbC5sZW5ndGhcbiAgICB9ZWxzZXtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKytcbiAgICAgIGlmKGxlbmd0aCA9PT0gdGhpcy5zaXplKXtcbiAgICAgICAgdGhpcy5yZXNpemUoKVxuICAgICAgfVxuICAgICAgY29uc3QgYnVmID0gdGhpcy5jbG9uZSgpXG4gICAgICB0aGlzLmJ1ZlswXSA9IHZhbFxuICAgICAgYnVmLmNvcHkodGhpcy5idWYsMSwgMCwgbGVuZ3RoKVxuICAgIH1cbiAgfVxuICBhcHBlbmQodmFsKXtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aCsrXG4gICAgaWYobGVuZ3RoID09PSB0aGlzLnNpemUpe1xuICAgICAgdGhpcy5yZXNpemUoKVxuICAgIH1cbiAgICB0aGlzLmJ1ZltsZW5ndGhdID0gdmFsXG4gIH1cbiAgY2xvbmUoKXtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5idWYuc2xpY2UoMCwgdGhpcy5sZW5ndGgpKVxuICB9XG4gIHJlc2l6ZSgpe1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgdGhpcy5zaXplID0gdGhpcy5zaXplICogMlxuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyh0aGlzLnNpemUpXG4gICAgdGhpcy5idWYuY29weShidWYsMCwgMCwgbGVuZ3RoKVxuICAgIHRoaXMuYnVmID0gYnVmXG4gIH1cbiAgdG9TdHJpbmcoZW5jb2Rpbmcpe1xuICAgIGlmKGVuY29kaW5nKXtcbiAgICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZSgwLCB0aGlzLmxlbmd0aCkudG9TdHJpbmcoZW5jb2RpbmcpXG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmJ1Zi5zbGljZSgwLCB0aGlzLmxlbmd0aCkpXG4gICAgfVxuICB9XG4gIHRvSlNPTigpe1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCd1dGY4JylcbiAgfVxuICByZXNldCgpe1xuICAgIHRoaXMubGVuZ3RoID0gMFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVzaXplYWJsZUJ1ZmZlclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/csv-parse/lib/ResizeableBuffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/csv-parse/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/csv-parse/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for\nadditional information.\n*/\n\nconst { Transform } = __webpack_require__(/*! stream */ \"stream\")\nconst ResizeableBuffer = __webpack_require__(/*! ./ResizeableBuffer */ \"(ssr)/./node_modules/csv-parse/lib/ResizeableBuffer.js\")\n\n// white space characters\n// https://en.wikipedia.org/wiki/Whitespace_character\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types\n// \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\nconst tab = 9\nconst nl = 10 // \\n, 0x0A in hexadecimal, 10 in decimal\nconst np = 12\nconst cr = 13 // \\r, 0x0D in hexad√©cimal, 13 in decimal\nconst space = 32\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n}\n\nclass Parser extends Transform {\n  constructor(opts = {}){\n    super({...{readableObjectMode: true}, ...opts, encoding: null})\n    this.__originalOptions = opts\n    this.__normalizeOptions(opts)\n  }\n  __normalizeOptions(opts){\n    const options = {}\n    // Merge with user options\n    for(let opt in opts){\n      options[underscore(opt)] = opts[opt]\n    }\n    // Normalize option `encoding`\n    // Note: defined first because other options depends on it\n    // to convert chars/strings into buffers.\n    if(options.encoding === undefined || options.encoding === true){\n      options.encoding = 'utf8'\n    }else if(options.encoding === null || options.encoding === false){\n      options.encoding = null\n    }else if(typeof options.encoding !== 'string' && options.encoding !== null){\n      throw new CsvError('CSV_INVALID_OPTION_ENCODING', [\n        'Invalid option encoding:',\n        'encoding must be a string or null to return a buffer,',\n        `got ${JSON.stringify(options.encoding)}`\n      ], options)\n    }\n    // Normalize option `bom`\n    if(options.bom === undefined || options.bom === null || options.bom === false){\n      options.bom = false\n    }else if(options.bom !== true){\n      throw new CsvError('CSV_INVALID_OPTION_BOM', [\n        'Invalid option bom:', 'bom must be true,',\n        `got ${JSON.stringify(options.bom)}`\n      ], options)\n    }\n    // Normalize option `cast`\n    let fnCastField = null\n    if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){\n      options.cast = undefined\n    }else if(typeof options.cast === 'function'){\n      fnCastField = options.cast\n      options.cast = true\n    }else if(options.cast !== true){\n      throw new CsvError('CSV_INVALID_OPTION_CAST', [\n        'Invalid option cast:', 'cast must be true or a function,',\n        `got ${JSON.stringify(options.cast)}`\n      ], options)\n    }\n    // Normalize option `cast_date`\n    if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){\n      options.cast_date = false\n    }else if(options.cast_date === true){\n      options.cast_date = function(value){\n        const date = Date.parse(value)\n        return !isNaN(date) ? new Date(date) : value\n      }\n    }else{\n      throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', [\n        'Invalid option cast_date:', 'cast_date must be true or a function,',\n        `got ${JSON.stringify(options.cast_date)}`\n      ], options)\n    }\n    // Normalize option `columns`\n    let fnFirstLineToHeaders = null\n    if(options.columns === true){\n      // Fields in the first line are converted as-is to columns\n      fnFirstLineToHeaders = undefined\n    }else if(typeof options.columns === 'function'){\n      fnFirstLineToHeaders = options.columns\n      options.columns = true\n    }else if(Array.isArray(options.columns)){\n      options.columns = normalizeColumnsArray(options.columns)\n    }else if(options.columns === undefined || options.columns === null || options.columns === false){\n      options.columns = false\n    }else{\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS', [\n        'Invalid option columns:',\n        'expect an array, a function or true,',\n        `got ${JSON.stringify(options.columns)}`\n      ], options)\n    }\n    // Normalize option `columns_duplicates_to_array`\n    if(options.columns_duplicates_to_array === undefined || options.columns_duplicates_to_array === null || options.columns_duplicates_to_array === false){\n      options.columns_duplicates_to_array = false\n    }else if(options.columns_duplicates_to_array !== true){\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', [\n        'Invalid option columns_duplicates_to_array:',\n        'expect an boolean,',\n        `got ${JSON.stringify(options.columns_duplicates_to_array)}`\n      ], options)\n    }else if(options.columns === false){\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', [\n        'Invalid option columns_duplicates_to_array:',\n        'the `columns` mode must be activated.'\n      ], options)\n    }\n    // Normalize option `comment`\n    if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){\n      options.comment = null\n    }else{\n      if(typeof options.comment === 'string'){\n        options.comment = Buffer.from(options.comment, options.encoding)\n      }\n      if(!Buffer.isBuffer(options.comment)){\n        throw new CsvError('CSV_INVALID_OPTION_COMMENT', [\n          'Invalid option comment:',\n          'comment must be a buffer or a string,',\n          `got ${JSON.stringify(options.comment)}`\n        ], options)\n      }\n    }\n    // Normalize option `delimiter`\n    const delimiter_json = JSON.stringify(options.delimiter)\n    if(!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter]\n    if(options.delimiter.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n        'Invalid option delimiter:',\n        'delimiter must be a non empty string or buffer or array of string|buffer,',\n        `got ${delimiter_json}`\n      ], options)\n    }\n    options.delimiter = options.delimiter.map(function(delimiter){\n      if(delimiter === undefined || delimiter === null || delimiter === false){\n        return Buffer.from(',', options.encoding)\n      }\n      if(typeof delimiter === 'string'){\n        delimiter = Buffer.from(delimiter, options.encoding)\n      }\n      if( !Buffer.isBuffer(delimiter) || delimiter.length === 0){\n        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n          'Invalid option delimiter:',\n          'delimiter must be a non empty string or buffer or array of string|buffer,',\n          `got ${delimiter_json}`\n        ], options)\n      }\n      return delimiter\n    })\n    // Normalize option `escape`\n    if(options.escape === undefined || options.escape === true){\n      options.escape = Buffer.from('\"', options.encoding)\n    }else if(typeof options.escape === 'string'){\n      options.escape = Buffer.from(options.escape, options.encoding)\n    }else if (options.escape === null || options.escape === false){\n      options.escape = null\n    }\n    if(options.escape !== null){\n      if(!Buffer.isBuffer(options.escape)){\n        throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`)\n      }\n    }\n    // Normalize option `from`\n    if(options.from === undefined || options.from === null){\n      options.from = 1\n    }else{\n      if(typeof options.from === 'string' && /\\d+/.test(options.from)){\n        options.from = parseInt(options.from)\n      }\n      if(Number.isInteger(options.from)){\n        if(options.from < 0){\n          throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`)\n      }\n    }\n    // Normalize option `from_line`\n    if(options.from_line === undefined || options.from_line === null){\n      options.from_line = 1\n    }else{\n      if(typeof options.from_line === 'string' && /\\d+/.test(options.from_line)){\n        options.from_line = parseInt(options.from_line)\n      }\n      if(Number.isInteger(options.from_line)){\n        if(options.from_line <= 0){\n          throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`)\n      }\n    }\n    // Normalize options `ignore_last_delimiters`\n    if(options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null){\n      options.ignore_last_delimiters = false\n    }else if(typeof options.ignore_last_delimiters === 'number'){\n      options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters)\n      if(options.ignore_last_delimiters === 0){\n        options.ignore_last_delimiters = false\n      }\n    }else if(typeof options.ignore_last_delimiters !== 'boolean'){\n      throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', [\n        'Invalid option `ignore_last_delimiters`:',\n        'the value must be a boolean value or an integer,',\n        `got ${JSON.stringify(options.ignore_last_delimiters)}`\n      ], options)\n    }\n    if(options.ignore_last_delimiters === true && options.columns === false){\n      throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', [\n        'The option `ignore_last_delimiters`',\n        'requires the activation of the `columns` option'\n      ], options)\n    }\n    // Normalize option `info`\n    if(options.info === undefined || options.info === null || options.info === false){\n      options.info = false\n    }else if(options.info !== true){\n      throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`)\n    }\n    // Normalize option `max_record_size`\n    if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){\n      options.max_record_size = 0\n    }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0){\n      // Great, nothing to do\n    }else if(typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)){\n      options.max_record_size = parseInt(options.max_record_size)\n    }else{\n      throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`)\n    }\n    // Normalize option `objname`\n    if(options.objname === undefined || options.objname === null || options.objname === false){\n      options.objname = undefined\n    }else if(Buffer.isBuffer(options.objname)){\n      if(options.objname.length === 0){\n        throw new Error(`Invalid Option: objname must be a non empty buffer`)\n      }\n      if(options.encoding === null){\n        // Don't call `toString`, leave objname as a buffer\n      }else{\n        options.objname = options.objname.toString(options.encoding)\n      }\n    }else if(typeof options.objname === 'string'){\n      if(options.objname.length === 0){\n        throw new Error(`Invalid Option: objname must be a non empty string`)\n      }\n      // Great, nothing to do\n    }else{\n      throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`)\n    }\n    // Normalize option `on_record`\n    if(options.on_record === undefined || options.on_record === null){\n      options.on_record = undefined\n    }else if(typeof options.on_record !== 'function'){\n      throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', [\n        'Invalid option `on_record`:',\n        'expect a function,',\n        `got ${JSON.stringify(options.on_record)}`\n      ], options)\n    }\n    // Normalize option `quote`\n    if(options.quote === null || options.quote === false || options.quote === ''){\n      options.quote = null\n    }else{\n      if(options.quote === undefined || options.quote === true){\n        options.quote = Buffer.from('\"', options.encoding)\n      }else if(typeof options.quote === 'string'){\n        options.quote = Buffer.from(options.quote, options.encoding)\n      }\n      if(!Buffer.isBuffer(options.quote)){\n        throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`)\n      }\n    }\n    // Normalize option `raw`\n    if(options.raw === undefined || options.raw === null || options.raw === false){\n      options.raw = false\n    }else if(options.raw !== true){\n      throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`)\n    }\n    // Normalize option `record_delimiter`\n    if(!options.record_delimiter){\n      options.record_delimiter = []\n    }else if(!Array.isArray(options.record_delimiter)){\n      options.record_delimiter = [options.record_delimiter]\n    }\n    options.record_delimiter = options.record_delimiter.map( function(rd){\n      if(typeof rd === 'string'){\n        rd = Buffer.from(rd, options.encoding)\n      }\n      return rd\n    })\n    // Normalize option `relax`\n    if(typeof options.relax === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax === undefined || options.relax === null){\n      options.relax = false\n    }else{\n      throw new Error(`Invalid Option: relax must be a boolean, got ${JSON.stringify(options.relax)}`)\n    }\n    // Normalize option `relax_column_count`\n    if(typeof options.relax_column_count === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count === undefined || options.relax_column_count === null){\n      options.relax_column_count = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`)\n    }\n    if(typeof options.relax_column_count_less === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count_less === undefined || options.relax_column_count_less === null){\n      options.relax_column_count_less = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`)\n    }\n    if(typeof options.relax_column_count_more === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count_more === undefined || options.relax_column_count_more === null){\n      options.relax_column_count_more = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`)\n    }\n    // Normalize option `skip_empty_lines`\n    if(typeof options.skip_empty_lines === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){\n      options.skip_empty_lines = false\n    }else{\n      throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`)\n    }\n    // Normalize option `skip_lines_with_empty_values`\n    if(typeof options.skip_lines_with_empty_values === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null){\n      options.skip_lines_with_empty_values = false\n    }else{\n      throw new Error(`Invalid Option: skip_lines_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_lines_with_empty_values)}`)\n    }\n    // Normalize option `skip_lines_with_error`\n    if(typeof options.skip_lines_with_error === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_lines_with_error === undefined || options.skip_lines_with_error === null){\n      options.skip_lines_with_error = false\n    }else{\n      throw new Error(`Invalid Option: skip_lines_with_error must be a boolean, got ${JSON.stringify(options.skip_lines_with_error)}`)\n    }\n    // Normalize option `rtrim`\n    if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){\n      options.rtrim = false\n    }else if(options.rtrim !== true){\n      throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`)\n    }\n    // Normalize option `ltrim`\n    if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){\n      options.ltrim = false\n    }else if(options.ltrim !== true){\n      throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`)\n    }\n    // Normalize option `trim`\n    if(options.trim === undefined || options.trim === null || options.trim === false){\n      options.trim = false\n    }else if(options.trim !== true){\n      throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`)\n    }\n    // Normalize options `trim`, `ltrim` and `rtrim`\n    if(options.trim === true && opts.ltrim !== false){\n      options.ltrim = true\n    }else if(options.ltrim !== true){\n      options.ltrim = false\n    }\n    if(options.trim === true && opts.rtrim !== false){\n      options.rtrim = true\n    }else if(options.rtrim !== true){\n      options.rtrim = false\n    }\n    // Normalize option `to`\n    if(options.to === undefined || options.to === null){\n      options.to = -1\n    }else{\n      if(typeof options.to === 'string' && /\\d+/.test(options.to)){\n        options.to = parseInt(options.to)\n      }\n      if(Number.isInteger(options.to)){\n        if(options.to <= 0){\n          throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`)\n      }\n    }\n    // Normalize option `to_line`\n    if(options.to_line === undefined || options.to_line === null){\n      options.to_line = -1\n    }else{\n      if(typeof options.to_line === 'string' && /\\d+/.test(options.to_line)){\n        options.to_line = parseInt(options.to_line)\n      }\n      if(Number.isInteger(options.to_line)){\n        if(options.to_line <= 0){\n          throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`)\n      }\n    }\n    this.info = {\n      bytes: 0,\n      comment_lines: 0,\n      empty_lines: 0,\n      invalid_field_length: 0,\n      lines: 1,\n      records: 0\n    }\n    this.options = options\n    this.state = {\n      bomSkipped: false,\n      bufBytesStart: 0,\n      castField: fnCastField,\n      commenting: false,\n      // Current error encountered by a record\n      error: undefined,\n      enabled: options.from_line === 1,\n      escaping: false,\n      // escapeIsQuote: options.escape === options.quote,\n      escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,\n      // columns can be `false`, `true`, `Array`\n      expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,\n      field: new ResizeableBuffer(20),\n      firstLineToHeaders: fnFirstLineToHeaders,\n      needMoreDataSize: Math.max(\n        // Skip if the remaining buffer smaller than comment\n        options.comment !== null ? options.comment.length : 0,\n        // Skip if the remaining buffer can be delimiter\n        ...options.delimiter.map( (delimiter) => delimiter.length),\n        // Skip if the remaining buffer can be escape sequence\n        options.quote !== null ? options.quote.length : 0,\n      ),\n      previousBuf: undefined,\n      quoting: false,\n      stop: false,\n      rawBuffer: new ResizeableBuffer(100),\n      record: [],\n      recordHasError: false,\n      record_length: 0,\n      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map( (v) => v.length)),\n      trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\\t', options.encoding)[0]],\n      wasQuoting: false,\n      wasRowDelimiter: false\n    }\n  }\n  // Implementation of `Transform._transform`\n  _transform(buf, encoding, callback){\n    if(this.state.stop === true){\n      return\n    }\n    const err = this.__parse(buf, false)\n    if(err !== undefined){\n      this.state.stop = true\n    }\n    callback(err)\n  }\n  // Implementation of `Transform._flush`\n  _flush(callback){\n    if(this.state.stop === true){\n      return\n    }\n    const err = this.__parse(undefined, true)\n    callback(err)\n  }\n  // Central parser implementation\n  __parse(nextBuf, end){\n    const {bom, comment, escape, from_line, ltrim, max_record_size, quote, raw, relax, rtrim, skip_empty_lines, to, to_line} = this.options\n    let {record_delimiter} = this.options\n    const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state\n    let buf\n    if(previousBuf === undefined){\n      if(nextBuf === undefined){\n        // Handle empty string\n        this.push(null)\n        return\n      }else{\n        buf = nextBuf\n      }\n    }else if(previousBuf !== undefined && nextBuf === undefined){\n      buf = previousBuf\n    }else{\n      buf = Buffer.concat([previousBuf, nextBuf])\n    }\n    // Handle UTF BOM\n    if(bomSkipped === false){\n      if(bom === false){\n        this.state.bomSkipped = true\n      }else if(buf.length < 3){\n        // No enough data\n        if(end === false){\n          // Wait for more data\n          this.state.previousBuf = buf\n          return\n        }\n      }else{\n        for(let encoding in boms){\n          if(boms[encoding].compare(buf, 0, boms[encoding].length) === 0){\n            // Skip BOM\n            let bomLength = boms[encoding].length\n            this.state.bufBytesStart += bomLength\n            buf = buf.slice(bomLength)\n            // Renormalize original options with the new encoding\n            this.__normalizeOptions({...this.__originalOptions, encoding: encoding})\n            break\n          }\n        }\n        this.state.bomSkipped = true\n      }\n    }\n    const bufLen = buf.length\n    let pos\n    for(pos = 0; pos < bufLen; pos++){\n      // Ensure we get enough space to look ahead\n      // There should be a way to move this out of the loop\n      if(this.__needMoreData(pos, bufLen, end)){\n        break\n      }\n      if(this.state.wasRowDelimiter === true){\n        this.info.lines++\n        this.state.wasRowDelimiter = false\n      }\n      if(to_line !== -1 && this.info.lines > to_line){\n        this.state.stop = true\n        this.push(null)\n        return\n      }\n      // Auto discovery of record_delimiter, unix, mac and windows supported\n      if(this.state.quoting === false && record_delimiter.length === 0){\n        const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos)\n        if(record_delimiterCount){\n          record_delimiter = this.options.record_delimiter\n        }\n      }\n      const chr = buf[pos]\n      if(raw === true){\n        rawBuffer.append(chr)\n      }\n      if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false ){\n        this.state.wasRowDelimiter = true\n      }\n      // Previous char was a valid escape char\n      // treat the current char as a regular char\n      if(this.state.escaping === true){\n        this.state.escaping = false\n      }else{\n        // Escape is only active inside quoted fields\n        // We are quoting, the char is an escape chr and there is a chr to escape\n        // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n        if(escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen){\n          if(escapeIsQuote){\n            if(this.__isQuote(buf, pos+escape.length)){\n              this.state.escaping = true\n              pos += escape.length - 1\n              continue\n            }\n          }else{\n            this.state.escaping = true\n            pos += escape.length - 1\n            continue\n          }\n        }\n        // Not currently escaping and chr is a quote\n        // TODO: need to compare bytes instead of single char\n        if(this.state.commenting === false && this.__isQuote(buf, pos)){\n          if(this.state.quoting === true){\n            const nextChr = buf[pos+quote.length]\n            const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr)\n            const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+quote.length, nextChr)\n            const isNextChrDelimiter = this.__isDelimiter(buf, pos+quote.length, nextChr)\n            const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos+quote.length) : this.__isRecordDelimiter(nextChr, buf, pos+quote.length)\n            // Escape a quote\n            // Treat next char as a regular character\n            if(escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)){\n              pos += escape.length - 1\n            }else if(!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable){\n              this.state.quoting = false\n              this.state.wasQuoting = true\n              pos += quote.length - 1\n              continue\n            }else if(relax === false){\n              const err = this.__error(\n                new CsvError('CSV_INVALID_CLOSING_QUOTE', [\n                  'Invalid Closing Quote:',\n                  `got \"${String.fromCharCode(nextChr)}\"`,\n                  `at line ${this.info.lines}`,\n                  'instead of delimiter, record delimiter, trimable character',\n                  '(if activated) or comment',\n                ], this.options, this.__infoField())\n              )\n              if(err !== undefined) return err\n            }else{\n              this.state.quoting = false\n              this.state.wasQuoting = true\n              this.state.field.prepend(quote)\n              pos += quote.length - 1\n            }\n          }else{\n            if(this.state.field.length !== 0){\n              // In relax mode, treat opening quote preceded by chrs as regular\n              if( relax === false ){\n                const err = this.__error(\n                  new CsvError('INVALID_OPENING_QUOTE', [\n                    'Invalid Opening Quote:',\n                    `a quote is found inside a field at line ${this.info.lines}`,\n                  ], this.options, this.__infoField(), {\n                    field: this.state.field,\n                  })\n                )\n                if(err !== undefined) return err\n              }\n            }else{\n              this.state.quoting = true\n              pos += quote.length - 1\n              continue\n            }\n          }\n        }\n        if(this.state.quoting === false){\n          let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos)\n          if(recordDelimiterLength !== 0){\n            // Do not emit comments which take a full line\n            const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0)\n            if(skipCommentLine){\n              this.info.comment_lines++\n              // Skip full comment line\n            }else{\n              // Activate records emition if above from_line\n              if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0) >= from_line){\n                this.state.enabled = true\n                this.__resetField()\n                this.__resetRecord()\n                pos += recordDelimiterLength - 1\n                continue\n              }\n              // Skip if line is empty and skip_empty_lines activated\n              if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){\n                this.info.empty_lines++\n                pos += recordDelimiterLength - 1\n                continue\n              }\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField()\n              if(errField !== undefined) return errField\n              this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n              const errRecord = this.__onRecord()\n              if(errRecord !== undefined) return errRecord\n              if(to !== -1 && this.info.records >= to){\n                this.state.stop = true\n                this.push(null)\n                return\n              }\n            }\n            this.state.commenting = false\n            pos += recordDelimiterLength - 1\n            continue\n          }\n          if(this.state.commenting){\n            continue\n          }\n          const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr)\n          if(commentCount !== 0){\n            this.state.commenting = true\n            continue\n          }\n          let delimiterLength = this.__isDelimiter(buf, pos, chr)\n          if(delimiterLength !== 0){\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField()\n            if(errField !== undefined) return errField\n            pos += delimiterLength - 1\n            continue\n          }\n        }\n      }\n      if(this.state.commenting === false){\n        if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){\n          const err = this.__error(\n            new CsvError('CSV_MAX_RECORD_SIZE', [\n              'Max Record Size:',\n              'record exceed the maximum number of tolerated bytes',\n              `of ${max_record_size}`,\n              `at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          )\n          if(err !== undefined) return err\n        }\n      }\n      const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr)\n      // rtrim in non quoting is handle in __onField\n      const rappend = rtrim === false || this.state.wasQuoting === false\n      if( lappend === true && rappend === true ){\n        this.state.field.append(chr)\n      }else if(rtrim === true && !this.__isCharTrimable(chr)){\n        const err = this.__error(\n          new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [\n            'Invalid Closing Quote:',\n            'found non trimable byte after quote',\n            `at line ${this.info.lines}`,\n          ], this.options, this.__infoField())\n        )\n        if(err !== undefined) return err\n      }\n    }\n    if(end === true){\n      // Ensure we are not ending in a quoting state\n      if(this.state.quoting === true){\n        const err = this.__error(\n          new CsvError('CSV_QUOTE_NOT_CLOSED', [\n            'Quote Not Closed:',\n            `the parsing is finished with an opening quote at line ${this.info.lines}`,\n          ], this.options, this.__infoField())\n        )\n        if(err !== undefined) return err\n      }else{\n        // Skip last line if it has no characters\n        if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){\n          this.info.bytes = this.state.bufBytesStart + pos;\n          const errField = this.__onField()\n          if(errField !== undefined) return errField\n          const errRecord = this.__onRecord()\n          if(errRecord !== undefined) return errRecord\n        }else if(this.state.wasRowDelimiter === true){\n          this.info.empty_lines++\n        }else if(this.state.commenting === true){\n          this.info.comment_lines++\n        }\n      }\n    }else{\n      this.state.bufBytesStart += pos\n      this.state.previousBuf = buf.slice(pos)\n    }\n    if(this.state.wasRowDelimiter === true){\n      this.info.lines++\n      this.state.wasRowDelimiter = false\n    }\n  }\n  __onRecord(){\n    const {columns, columns_duplicates_to_array, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_lines_with_empty_values} = this.options\n    const {enabled, record} = this.state\n    if(enabled === false){\n      return this.__resetRecord()\n    }\n    // Convert the first line into column names\n    const recordLength = record.length\n    if(columns === true){\n      if(skip_lines_with_empty_values === true && isRecordEmpty(record)){\n        this.__resetRecord()\n        return\n      }\n      return this.__firstLineToColumns(record)\n    }\n    if(columns === false && this.info.records === 0){\n      this.state.expectedRecordLength = recordLength\n    }\n    if(recordLength !== this.state.expectedRecordLength){\n      const err = columns === false ?\n        // Todo: rename CSV_INCONSISTENT_RECORD_LENGTH to\n        // CSV_RECORD_INCONSISTENT_FIELDS_LENGTH\n        new CsvError('CSV_INCONSISTENT_RECORD_LENGTH', [\n          'Invalid Record Length:',\n          `expect ${this.state.expectedRecordLength},`,\n          `got ${recordLength} on line ${this.info.lines}`,\n        ], this.options, this.__infoField(), {\n          record: record,\n        })\n      :\n        // Todo: rename CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH to\n        // CSV_RECORD_INCONSISTENT_COLUMNS\n        new CsvError('CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH', [\n          'Invalid Record Length:',\n          `columns length is ${columns.length},`, // rename columns\n          `got ${recordLength} on line ${this.info.lines}`,\n        ], this.options, this.__infoField(), {\n          record: record,\n        })\n      if(relax_column_count === true ||\n        (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||\n        (relax_column_count_more === true && recordLength > this.state.expectedRecordLength) ){\n        this.info.invalid_field_length++\n        this.state.error = err\n      // Error is undefined with skip_lines_with_error\n      }else{\n        const finalErr = this.__error(err)\n        if(finalErr) return finalErr\n      }\n    }\n    if(skip_lines_with_empty_values === true && isRecordEmpty(record)){\n      this.__resetRecord()\n      return\n    }\n    if(this.state.recordHasError === true){\n      this.__resetRecord()\n      this.state.recordHasError = false\n      return\n    }\n    this.info.records++\n    if(from === 1 || this.info.records >= from){\n      // With columns, records are object\n      if(columns !== false){\n        const obj = {}\n        // Transform record array to an object\n        for(let i = 0, l = record.length; i < l; i++){\n          if(columns[i] === undefined || columns[i].disabled) continue\n          // Turn duplicate columns into an array\n          if (columns_duplicates_to_array === true && obj[columns[i].name] !== undefined) {\n            if (Array.isArray(obj[columns[i].name])) {\n              obj[columns[i].name] = obj[columns[i].name].concat(record[i])\n            } else {\n              obj[columns[i].name] = [obj[columns[i].name], record[i]]\n            }\n          } else {\n            obj[columns[i].name] = record[i]\n          }\n        }\n        const {objname} = this.options\n        // Without objname (default)\n        if(objname === undefined){\n          if(raw === true || info === true){\n            const err = this.__push(Object.assign(\n              {record: obj},\n              (raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {}),\n              (info === true ? {info: this.__infoRecord()}: {})\n            ))\n            if(err){\n              return err\n            }\n          }else{\n            const err = this.__push(obj)\n            if(err){\n              return err\n            }\n          }\n        // With objname (default)\n        }else{\n          if(raw === true || info === true){\n            const err = this.__push(Object.assign(\n              {record: [obj[objname], obj]},\n              raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n              info === true ? {info: this.__infoRecord()}: {}\n            ))\n            if(err){\n              return err\n            }\n          }else{\n            const err = this.__push([obj[objname], obj])\n            if(err){\n              return err\n            }\n          }\n        }\n      // Without columns, records are array\n      }else{\n        if(raw === true || info === true){\n          const err = this.__push(Object.assign(\n            {record: record},\n            raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n            info === true ? {info: this.__infoRecord()}: {}\n          ))\n          if(err){\n            return err\n          }\n        }else{\n          const err = this.__push(record)\n          if(err){\n            return err\n          }\n        }\n      }\n    }\n    this.__resetRecord()\n  }\n  __firstLineToColumns(record){\n    const {firstLineToHeaders} = this.state\n    try{\n      const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record)\n      if(!Array.isArray(headers)){\n        return this.__error(\n          new CsvError('CSV_INVALID_COLUMN_MAPPING', [\n            'Invalid Column Mapping:',\n            'expect an array from column function,',\n            `got ${JSON.stringify(headers)}`\n          ], this.options, this.__infoField(), {\n            headers: headers,\n          })\n        )\n      }\n      const normalizedHeaders = normalizeColumnsArray(headers)\n      this.state.expectedRecordLength = normalizedHeaders.length\n      this.options.columns = normalizedHeaders\n      this.__resetRecord()\n      return\n    }catch(err){\n      return err\n    }\n  }\n  __resetRecord(){\n    if(this.options.raw === true){\n      this.state.rawBuffer.reset()\n    }\n    this.state.error = undefined\n    this.state.record = []\n    this.state.record_length = 0\n  }\n  __onField(){\n    const {cast, encoding, rtrim, max_record_size} = this.options\n    const {enabled, wasQuoting} = this.state\n    // Short circuit for the from_line options\n    if(enabled === false){\n      return this.__resetField()\n    }\n    let field = this.state.field.toString(encoding)\n    if(rtrim === true && wasQuoting === false){\n      field = field.trimRight()\n    }\n    if(cast === true){\n      const [err, f] = this.__cast(field)\n      if(err !== undefined) return err\n      field = f\n    }\n    this.state.record.push(field)\n    // Increment record length if record size must not exceed a limit\n    if(max_record_size !== 0 && typeof field === 'string'){\n      this.state.record_length += field.length\n    }\n    this.__resetField()\n  }\n  __resetField(){\n    this.state.field.reset()\n    this.state.wasQuoting = false\n  }\n  __push(record){\n    const {on_record} = this.options\n    if(on_record !== undefined){\n      const info = this.__infoRecord()\n      try{\n        record = on_record.call(null, record, info)\n      }catch(err){\n        return err\n      }\n      if(record === undefined || record === null){ return }\n    }\n    this.push(record)\n  }\n  // Return a tuple with the error and the casted value\n  __cast(field){\n    const {columns, relax_column_count} = this.options\n    const isColumns = Array.isArray(columns)\n    // Dont loose time calling cast\n    // because the final record is an object\n    // and this field can't be associated to a key present in columns\n    if( isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length ){\n      return [undefined, undefined]\n    }\n    if(this.state.castField !== null){\n      try{\n        const info = this.__infoField()\n        return [undefined, this.state.castField.call(null, field, info)]\n      }catch(err){\n        return [err]\n      }\n    }\n    if(this.__isFloat(field)){\n      return [undefined, parseFloat(field)]\n    }else if(this.options.cast_date !== false){\n      const info = this.__infoField()\n      return [undefined, this.options.cast_date.call(null, field, info)]\n    }\n    return [undefined, field]\n  }\n  // Helper to test if a character is a space or a line delimiter\n  __isCharTrimable(chr){\n    return chr === space || chr === tab || chr === cr || chr === nl || chr === np\n  }\n  // Keep it in case we implement the `cast_int` option\n  // __isInt(value){\n  //   // return Number.isInteger(parseInt(value))\n  //   // return !isNaN( parseInt( obj ) );\n  //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n  // }\n  __isFloat(value){\n    return (value - parseFloat( value ) + 1) >= 0 // Borrowed from jquery\n  }\n  __compareBytes(sourceBuf, targetBuf, targetPos, firstByte){\n    if(sourceBuf[0] !== firstByte) return 0\n    const sourceLength = sourceBuf.length\n    for(let i = 1; i < sourceLength; i++){\n      if(sourceBuf[i] !== targetBuf[targetPos+i]) return 0\n    }\n    return sourceLength\n  }\n  __needMoreData(i, bufLen, end){\n    if(end) return false\n    const {quote} = this.options\n    const {quoting, needMoreDataSize, recordDelimiterMaxLength} = this.state\n    const numOfCharLeft = bufLen - i - 1\n    const requiredLength = Math.max(\n      needMoreDataSize,\n      // Skip if the remaining buffer smaller than record delimiter\n      recordDelimiterMaxLength,\n      // Skip if the remaining buffer can be record delimiter following the closing quote\n      // 1 is for quote.length\n      quoting ? (quote.length + recordDelimiterMaxLength) : 0,\n    )\n    return numOfCharLeft < requiredLength\n  }\n  __isDelimiter(buf, pos, chr){\n    const {delimiter, ignore_last_delimiters} = this.options\n    if(ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1){\n      return 0\n    }else if(ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1){\n      return 0\n    }\n    loop1: for(let i = 0; i < delimiter.length; i++){\n      const del = delimiter[i]\n      if(del[0] === chr){\n        for(let j = 1; j < del.length; j++){\n          if(del[j] !== buf[pos+j]) continue loop1\n        }\n        return del.length\n      }\n    }\n    return 0\n  }\n  __isRecordDelimiter(chr, buf, pos){\n    const {record_delimiter} = this.options\n    const recordDelimiterLength = record_delimiter.length\n    loop1: for(let i = 0; i < recordDelimiterLength; i++){\n      const rd = record_delimiter[i]\n      const rdLength = rd.length\n      if(rd[0] !== chr){\n        continue\n      }\n      for(let j = 1; j < rdLength; j++){\n        if(rd[j] !== buf[pos+j]){\n          continue loop1\n        }\n      }\n      return rd.length\n    }\n    return 0\n  }\n  __isEscape(buf, pos, chr){\n    const {escape} = this.options\n    if(escape === null) return false\n    const l = escape.length\n    if(escape[0] === chr){\n      for(let i = 0; i < l; i++){\n        if(escape[i] !== buf[pos+i]){\n          return false\n        }\n      }\n      return true\n    }\n    return false\n  }\n  __isQuote(buf, pos){\n    const {quote} = this.options\n    if(quote === null) return false\n    const l = quote.length\n    for(let i = 0; i < l; i++){\n      if(quote[i] !== buf[pos+i]){\n        return false\n      }\n    }\n    return true\n  }\n  __autoDiscoverRecordDelimiter(buf, pos){\n    const {encoding} = this.options\n    const chr = buf[pos]\n    if(chr === cr){\n      if(buf[pos+1] === nl){\n        this.options.record_delimiter.push(Buffer.from('\\r\\n', encoding))\n        this.state.recordDelimiterMaxLength = 2\n        return 2\n      }else{\n        this.options.record_delimiter.push(Buffer.from('\\r', encoding))\n        this.state.recordDelimiterMaxLength = 1\n        return 1\n      }\n    }else if(chr === nl){\n      this.options.record_delimiter.push(Buffer.from('\\n', encoding))\n      this.state.recordDelimiterMaxLength = 1\n      return 1\n    }\n    return 0\n  }\n  __error(msg){\n    const {skip_lines_with_error} = this.options\n    const err = typeof msg === 'string' ? new Error(msg) : msg\n    if(skip_lines_with_error){\n      this.state.recordHasError = true\n      this.emit('skip', err)\n      return undefined\n    }else{\n      return err\n    }\n  }\n  __infoDataSet(){\n    return {\n      ...this.info,\n      columns: this.options.columns\n    }\n  }\n  __infoRecord(){\n    const {columns} = this.options\n    return {\n      ...this.__infoDataSet(),\n      error: this.state.error,\n      header: columns === true,\n      index: this.state.record.length,\n    }\n  }\n  __infoField(){\n    const {columns} = this.options\n    const isColumns = Array.isArray(columns)\n    return {\n      ...this.__infoRecord(),\n      column: isColumns === true ?\n        ( columns.length > this.state.record.length ?\n          columns[this.state.record.length].name :\n          null\n        ) :\n        this.state.record.length,\n      quoting: this.state.wasQuoting,\n    }\n  }\n}\n\nconst parse = function(){\n  let data, options, callback\n  for(let i in arguments){\n    const argument = arguments[i]\n    const type = typeof argument\n    if(data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))){\n      data = argument\n    }else if(options === undefined && isObject(argument)){\n      options = argument\n    }else if(callback === undefined && type === 'function'){\n      callback = argument\n    }else{\n      throw new CsvError('CSV_INVALID_ARGUMENT', [\n        'Invalid argument:',\n        `got ${JSON.stringify(argument)} at index ${i}`\n      ], options || {})\n    }\n  }\n  const parser = new Parser(options)\n  if(callback){\n    const records = options === undefined || options.objname === undefined ? [] : {}\n    parser.on('readable', function(){\n      let record\n      while((record = this.read()) !== null){\n        if(options === undefined || options.objname === undefined){\n          records.push(record)\n        }else{\n          records[record[0]] = record[1]\n        }\n      }\n    })\n    parser.on('error', function(err){\n      callback(err, undefined, parser.__infoDataSet())\n    })\n    parser.on('end', function(){\n      callback(undefined, records, parser.__infoDataSet())\n    })\n  }\n  if(data !== undefined){\n    // Give a chance for events to be registered later\n    if(typeof setImmediate === 'function'){\n      setImmediate(function(){\n        parser.write(data)\n        parser.end()\n      })\n    }else{\n      parser.write(data)\n      parser.end()\n    }\n  }\n  return parser\n}\n\nclass CsvError extends Error {\n  constructor(code, message, options, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ')\n    super(message)\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError)\n    }\n    this.code = code\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key]\n        this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value))\n      }\n    }\n  }\n}\n\nparse.Parser = Parser\n\nparse.CsvError = CsvError\n\nmodule.exports = parse\n\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase()\n  })\n}\n\nconst isObject = function(obj){\n  return (typeof obj === 'object' && obj !== null && !Array.isArray(obj))\n}\n\nconst isRecordEmpty = function(record){\n  return record.every( (field) => field == null || field.toString && field.toString().trim() === '' )\n}\n\nconst normalizeColumnsArray = function(columns){\n  const normalizedColumns = [];\n  for(let i = 0, l = columns.length; i < l; i++){\n    const column = columns[i]\n    if(column === undefined || column === null || column === false){\n      normalizedColumns[i] = { disabled: true }\n    }else if(typeof column === 'string'){\n      normalizedColumns[i] = { name: column }\n    }else if(isObject(column)){\n      if(typeof column.name !== 'string'){\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', [\n          'Option columns missing name:',\n          `property \"name\" is required at position ${i}`,\n          'when column is an object literal'\n        ])\n      }\n      normalizedColumns[i] = column\n    }else{\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', [\n        'Invalid column definition:',\n        'expect a string or a literal object,',\n        `got ${JSON.stringify(column)} at position ${i}`\n      ])\n    }\n  }\n  return normalizedColumns;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3N2LXBhcnNlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUN0Qyx5QkFBeUIsbUJBQU8sQ0FBQyxrRkFBb0I7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkIsV0FBVyxJQUFJLHlCQUF5QiwwQkFBMEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlDQUFpQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0RBQW9EO0FBQ25FO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRiwrQkFBK0I7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLDBCQUEwQjtBQUM1RztBQUNBLE9BQU87QUFDUCx3RUFBd0UsNkJBQTZCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRywrQkFBK0I7QUFDckk7QUFDQSxPQUFPO0FBQ1AsNkVBQTZFLCtCQUErQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0NBQStDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0VBQWdFLDZCQUE2QjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCx5RkFBeUYsd0NBQXdDO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtRkFBbUYsZ0JBQWdCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsOEJBQThCO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0RBQStELDRCQUE0QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsc0VBQXNFLDhCQUE4QjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxtRkFBbUYsMkNBQTJDO0FBQzlIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCx3RkFBd0YsZ0RBQWdEO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCx3RkFBd0YsZ0RBQWdEO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLGlGQUFpRix5Q0FBeUM7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsNkZBQTZGLHFEQUFxRDtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxzRkFBc0YsOENBQThDO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNFQUFzRSw4QkFBOEI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0VBQXNFLDhCQUE4QjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxRUFBcUUsNkJBQTZCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRix3QkFBd0I7QUFDdkg7QUFDQSxPQUFPO0FBQ1Asc0VBQXNFLHdCQUF3QjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csNkJBQTZCO0FBQ2pJO0FBQ0EsT0FBTztBQUNQLDJFQUEyRSw2QkFBNkI7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0hBQWtIO0FBQzdILFNBQVMsa0JBQWtCO0FBQzNCLFdBQVcsbURBQW1EO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsOENBQThDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkJBQTZCO0FBQ3ZELDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxnQkFBZ0I7QUFDL0U7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZ0JBQWdCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxS0FBcUs7QUFDaEwsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRCxpQkFBaUIsY0FBYyxVQUFVLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QyxpQkFBaUIsY0FBYyxVQUFVLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsK0JBQStCLDZDQUE2QyxJQUFJO0FBQ2hGLGdDQUFnQywwQkFBMEIsSUFBSTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLDhCQUE4Qiw2Q0FBNkMsSUFBSTtBQUMvRSwrQkFBK0IsMEJBQTBCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsNEJBQTRCLDZDQUE2QyxJQUFJO0FBQzdFLDZCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdDQUF3QztBQUNuRCxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxxREFBcUQ7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsMEJBQTBCLFdBQVcsRUFBRTtBQUN0RCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLEtBQUs7QUFDTCwrQkFBK0I7QUFDL0IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxFQUFFO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCLGNBQWMsRUFBRTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWV0YXBsZXgtdW1pLW5leHQtanMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvY3N2LXBhcnNlL2xpYi9pbmRleC5qcz9jMWJjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbkNTViBQYXJzZVxuXG5QbGVhc2UgbG9vayBhdCB0aGUgW3Byb2plY3QgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9jc3YuanMub3JnL3BhcnNlLykgZm9yXG5hZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuKi9cblxuY29uc3QgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCBSZXNpemVhYmxlQnVmZmVyID0gcmVxdWlyZSgnLi9SZXNpemVhYmxlQnVmZmVyJylcblxuLy8gd2hpdGUgc3BhY2UgY2hhcmFjdGVyc1xuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2hpdGVzcGFjZV9jaGFyYWN0ZXJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9ucy9DaGFyYWN0ZXJfQ2xhc3NlcyNUeXBlc1xuLy8gXFxmXFxuXFxyXFx0XFx2XFx1MDBhMFxcdTE2ODBcXHUyMDAwLVxcdTIwMGFcXHUyMDI4XFx1MjAyOVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZcbmNvbnN0IHRhYiA9IDlcbmNvbnN0IG5sID0gMTAgLy8gXFxuLCAweDBBIGluIGhleGFkZWNpbWFsLCAxMCBpbiBkZWNpbWFsXG5jb25zdCBucCA9IDEyXG5jb25zdCBjciA9IDEzIC8vIFxcciwgMHgwRCBpbiBoZXhhZMOpY2ltYWwsIDEzIGluIGRlY2ltYWxcbmNvbnN0IHNwYWNlID0gMzJcbmNvbnN0IGJvbXMgPSB7XG4gIC8vIE5vdGUsIHRoZSBmb2xsb3dpbmcgYXJlIGVxdWFsczpcbiAgLy8gQnVmZmVyLmZyb20oXCJcXHVmZWZmXCIpXG4gIC8vIEJ1ZmZlci5mcm9tKFsyMzksIDE4NywgMTkxXSlcbiAgLy8gQnVmZmVyLmZyb20oJ0VGQkJCRicsICdoZXgnKVxuICAndXRmOCc6IEJ1ZmZlci5mcm9tKFsyMzksIDE4NywgMTkxXSksXG4gIC8vIE5vdGUsIHRoZSBmb2xsb3dpbmcgYXJlIGVxdWFsczpcbiAgLy8gQnVmZmVyLmZyb20gXCJcXHVmZWZmXCIsICd1dGYxNmxlXG4gIC8vIEJ1ZmZlci5mcm9tKFsyNTUsIDI1NF0pXG4gICd1dGYxNmxlJzogQnVmZmVyLmZyb20oWzI1NSwgMjU0XSlcbn1cblxuY2xhc3MgUGFyc2VyIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KXtcbiAgICBzdXBlcih7Li4ue3JlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZX0sIC4uLm9wdHMsIGVuY29kaW5nOiBudWxsfSlcbiAgICB0aGlzLl9fb3JpZ2luYWxPcHRpb25zID0gb3B0c1xuICAgIHRoaXMuX19ub3JtYWxpemVPcHRpb25zKG9wdHMpXG4gIH1cbiAgX19ub3JtYWxpemVPcHRpb25zKG9wdHMpe1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7fVxuICAgIC8vIE1lcmdlIHdpdGggdXNlciBvcHRpb25zXG4gICAgZm9yKGxldCBvcHQgaW4gb3B0cyl7XG4gICAgICBvcHRpb25zW3VuZGVyc2NvcmUob3B0KV0gPSBvcHRzW29wdF1cbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZW5jb2RpbmdgXG4gICAgLy8gTm90ZTogZGVmaW5lZCBmaXJzdCBiZWNhdXNlIG90aGVyIG9wdGlvbnMgZGVwZW5kcyBvbiBpdFxuICAgIC8vIHRvIGNvbnZlcnQgY2hhcnMvc3RyaW5ncyBpbnRvIGJ1ZmZlcnMuXG4gICAgaWYob3B0aW9ucy5lbmNvZGluZyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZW5jb2RpbmcgPT09IHRydWUpe1xuICAgICAgb3B0aW9ucy5lbmNvZGluZyA9ICd1dGY4J1xuICAgIH1lbHNlIGlmKG9wdGlvbnMuZW5jb2RpbmcgPT09IG51bGwgfHwgb3B0aW9ucy5lbmNvZGluZyA9PT0gZmFsc2Upe1xuICAgICAgb3B0aW9ucy5lbmNvZGluZyA9IG51bGxcbiAgICB9ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5lbmNvZGluZyAhPT0gJ3N0cmluZycgJiYgb3B0aW9ucy5lbmNvZGluZyAhPT0gbnVsbCl7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoJ0NTVl9JTlZBTElEX09QVElPTl9FTkNPRElORycsIFtcbiAgICAgICAgJ0ludmFsaWQgb3B0aW9uIGVuY29kaW5nOicsXG4gICAgICAgICdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwgdG8gcmV0dXJuIGEgYnVmZmVyLCcsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmVuY29kaW5nKX1gXG4gICAgICBdLCBvcHRpb25zKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBib21gXG4gICAgaWYob3B0aW9ucy5ib20gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmJvbSA9PT0gbnVsbCB8fCBvcHRpb25zLmJvbSA9PT0gZmFsc2Upe1xuICAgICAgb3B0aW9ucy5ib20gPSBmYWxzZVxuICAgIH1lbHNlIGlmKG9wdGlvbnMuYm9tICE9PSB0cnVlKXtcbiAgICAgIHRocm93IG5ldyBDc3ZFcnJvcignQ1NWX0lOVkFMSURfT1BUSU9OX0JPTScsIFtcbiAgICAgICAgJ0ludmFsaWQgb3B0aW9uIGJvbTonLCAnYm9tIG11c3QgYmUgdHJ1ZSwnLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib20pfWBcbiAgICAgIF0sIG9wdGlvbnMpXG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGNhc3RgXG4gICAgbGV0IGZuQ2FzdEZpZWxkID0gbnVsbFxuICAgIGlmKG9wdGlvbnMuY2FzdCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdCA9PT0gbnVsbCB8fCBvcHRpb25zLmNhc3QgPT09IGZhbHNlIHx8IG9wdGlvbnMuY2FzdCA9PT0gJycpe1xuICAgICAgb3B0aW9ucy5jYXN0ID0gdW5kZWZpbmVkXG4gICAgfWVsc2UgaWYodHlwZW9mIG9wdGlvbnMuY2FzdCA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICBmbkNhc3RGaWVsZCA9IG9wdGlvbnMuY2FzdFxuICAgICAgb3B0aW9ucy5jYXN0ID0gdHJ1ZVxuICAgIH1lbHNlIGlmKG9wdGlvbnMuY2FzdCAhPT0gdHJ1ZSl7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoJ0NTVl9JTlZBTElEX09QVElPTl9DQVNUJywgW1xuICAgICAgICAnSW52YWxpZCBvcHRpb24gY2FzdDonLCAnY2FzdCBtdXN0IGJlIHRydWUgb3IgYSBmdW5jdGlvbiwnLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5jYXN0KX1gXG4gICAgICBdLCBvcHRpb25zKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBjYXN0X2RhdGVgXG4gICAgaWYob3B0aW9ucy5jYXN0X2RhdGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNhc3RfZGF0ZSA9PT0gbnVsbCB8fCBvcHRpb25zLmNhc3RfZGF0ZSA9PT0gZmFsc2UgfHwgb3B0aW9ucy5jYXN0X2RhdGUgPT09ICcnKXtcbiAgICAgIG9wdGlvbnMuY2FzdF9kYXRlID0gZmFsc2VcbiAgICB9ZWxzZSBpZihvcHRpb25zLmNhc3RfZGF0ZSA9PT0gdHJ1ZSl7XG4gICAgICBvcHRpb25zLmNhc3RfZGF0ZSA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgY29uc3QgZGF0ZSA9IERhdGUucGFyc2UodmFsdWUpXG4gICAgICAgIHJldHVybiAhaXNOYU4oZGF0ZSkgPyBuZXcgRGF0ZShkYXRlKSA6IHZhbHVlXG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoJ0NTVl9JTlZBTElEX09QVElPTl9DQVNUX0RBVEUnLCBbXG4gICAgICAgICdJbnZhbGlkIG9wdGlvbiBjYXN0X2RhdGU6JywgJ2Nhc3RfZGF0ZSBtdXN0IGJlIHRydWUgb3IgYSBmdW5jdGlvbiwnLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5jYXN0X2RhdGUpfWBcbiAgICAgIF0sIG9wdGlvbnMpXG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGNvbHVtbnNgXG4gICAgbGV0IGZuRmlyc3RMaW5lVG9IZWFkZXJzID0gbnVsbFxuICAgIGlmKG9wdGlvbnMuY29sdW1ucyA9PT0gdHJ1ZSl7XG4gICAgICAvLyBGaWVsZHMgaW4gdGhlIGZpcnN0IGxpbmUgYXJlIGNvbnZlcnRlZCBhcy1pcyB0byBjb2x1bW5zXG4gICAgICBmbkZpcnN0TGluZVRvSGVhZGVycyA9IHVuZGVmaW5lZFxuICAgIH1lbHNlIGlmKHR5cGVvZiBvcHRpb25zLmNvbHVtbnMgPT09ICdmdW5jdGlvbicpe1xuICAgICAgZm5GaXJzdExpbmVUb0hlYWRlcnMgPSBvcHRpb25zLmNvbHVtbnNcbiAgICAgIG9wdGlvbnMuY29sdW1ucyA9IHRydWVcbiAgICB9ZWxzZSBpZihBcnJheS5pc0FycmF5KG9wdGlvbnMuY29sdW1ucykpe1xuICAgICAgb3B0aW9ucy5jb2x1bW5zID0gbm9ybWFsaXplQ29sdW1uc0FycmF5KG9wdGlvbnMuY29sdW1ucylcbiAgICB9ZWxzZSBpZihvcHRpb25zLmNvbHVtbnMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNvbHVtbnMgPT09IG51bGwgfHwgb3B0aW9ucy5jb2x1bW5zID09PSBmYWxzZSl7XG4gICAgICBvcHRpb25zLmNvbHVtbnMgPSBmYWxzZVxuICAgIH1lbHNle1xuICAgICAgdGhyb3cgbmV3IENzdkVycm9yKCdDU1ZfSU5WQUxJRF9PUFRJT05fQ09MVU1OUycsIFtcbiAgICAgICAgJ0ludmFsaWQgb3B0aW9uIGNvbHVtbnM6JyxcbiAgICAgICAgJ2V4cGVjdCBhbiBhcnJheSwgYSBmdW5jdGlvbiBvciB0cnVlLCcsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmNvbHVtbnMpfWBcbiAgICAgIF0sIG9wdGlvbnMpXG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGNvbHVtbnNfZHVwbGljYXRlc190b19hcnJheWBcbiAgICBpZihvcHRpb25zLmNvbHVtbnNfZHVwbGljYXRlc190b19hcnJheSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY29sdW1uc19kdXBsaWNhdGVzX3RvX2FycmF5ID09PSBudWxsIHx8IG9wdGlvbnMuY29sdW1uc19kdXBsaWNhdGVzX3RvX2FycmF5ID09PSBmYWxzZSl7XG4gICAgICBvcHRpb25zLmNvbHVtbnNfZHVwbGljYXRlc190b19hcnJheSA9IGZhbHNlXG4gICAgfWVsc2UgaWYob3B0aW9ucy5jb2x1bW5zX2R1cGxpY2F0ZXNfdG9fYXJyYXkgIT09IHRydWUpe1xuICAgICAgdGhyb3cgbmV3IENzdkVycm9yKCdDU1ZfSU5WQUxJRF9PUFRJT05fQ09MVU1OU19EVVBMSUNBVEVTX1RPX0FSUkFZJywgW1xuICAgICAgICAnSW52YWxpZCBvcHRpb24gY29sdW1uc19kdXBsaWNhdGVzX3RvX2FycmF5OicsXG4gICAgICAgICdleHBlY3QgYW4gYm9vbGVhbiwnLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5jb2x1bW5zX2R1cGxpY2F0ZXNfdG9fYXJyYXkpfWBcbiAgICAgIF0sIG9wdGlvbnMpXG4gICAgfWVsc2UgaWYob3B0aW9ucy5jb2x1bW5zID09PSBmYWxzZSl7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoJ0NTVl9JTlZBTElEX09QVElPTl9DT0xVTU5TX0RVUExJQ0FURVNfVE9fQVJSQVknLCBbXG4gICAgICAgICdJbnZhbGlkIG9wdGlvbiBjb2x1bW5zX2R1cGxpY2F0ZXNfdG9fYXJyYXk6JyxcbiAgICAgICAgJ3RoZSBgY29sdW1uc2AgbW9kZSBtdXN0IGJlIGFjdGl2YXRlZC4nXG4gICAgICBdLCBvcHRpb25zKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBjb21tZW50YFxuICAgIGlmKG9wdGlvbnMuY29tbWVudCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY29tbWVudCA9PT0gbnVsbCB8fCBvcHRpb25zLmNvbW1lbnQgPT09IGZhbHNlIHx8IG9wdGlvbnMuY29tbWVudCA9PT0gJycpe1xuICAgICAgb3B0aW9ucy5jb21tZW50ID0gbnVsbFxuICAgIH1lbHNle1xuICAgICAgaWYodHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gJ3N0cmluZycpe1xuICAgICAgICBvcHRpb25zLmNvbW1lbnQgPSBCdWZmZXIuZnJvbShvcHRpb25zLmNvbW1lbnQsIG9wdGlvbnMuZW5jb2RpbmcpXG4gICAgICB9XG4gICAgICBpZighQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMuY29tbWVudCkpe1xuICAgICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoJ0NTVl9JTlZBTElEX09QVElPTl9DT01NRU5UJywgW1xuICAgICAgICAgICdJbnZhbGlkIG9wdGlvbiBjb21tZW50OicsXG4gICAgICAgICAgJ2NvbW1lbnQgbXVzdCBiZSBhIGJ1ZmZlciBvciBhIHN0cmluZywnLFxuICAgICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmNvbW1lbnQpfWBcbiAgICAgICAgXSwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZGVsaW1pdGVyYFxuICAgIGNvbnN0IGRlbGltaXRlcl9qc29uID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5kZWxpbWl0ZXIpXG4gICAgaWYoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5kZWxpbWl0ZXIpKSBvcHRpb25zLmRlbGltaXRlciA9IFtvcHRpb25zLmRlbGltaXRlcl1cbiAgICBpZihvcHRpb25zLmRlbGltaXRlci5sZW5ndGggPT09IDApe1xuICAgICAgdGhyb3cgbmV3IENzdkVycm9yKCdDU1ZfSU5WQUxJRF9PUFRJT05fREVMSU1JVEVSJywgW1xuICAgICAgICAnSW52YWxpZCBvcHRpb24gZGVsaW1pdGVyOicsXG4gICAgICAgICdkZWxpbWl0ZXIgbXVzdCBiZSBhIG5vbiBlbXB0eSBzdHJpbmcgb3IgYnVmZmVyIG9yIGFycmF5IG9mIHN0cmluZ3xidWZmZXIsJyxcbiAgICAgICAgYGdvdCAke2RlbGltaXRlcl9qc29ufWBcbiAgICAgIF0sIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMuZGVsaW1pdGVyID0gb3B0aW9ucy5kZWxpbWl0ZXIubWFwKGZ1bmN0aW9uKGRlbGltaXRlcil7XG4gICAgICBpZihkZWxpbWl0ZXIgPT09IHVuZGVmaW5lZCB8fCBkZWxpbWl0ZXIgPT09IG51bGwgfHwgZGVsaW1pdGVyID09PSBmYWxzZSl7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSgnLCcsIG9wdGlvbnMuZW5jb2RpbmcpXG4gICAgICB9XG4gICAgICBpZih0eXBlb2YgZGVsaW1pdGVyID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGRlbGltaXRlciA9IEJ1ZmZlci5mcm9tKGRlbGltaXRlciwgb3B0aW9ucy5lbmNvZGluZylcbiAgICAgIH1cbiAgICAgIGlmKCAhQnVmZmVyLmlzQnVmZmVyKGRlbGltaXRlcikgfHwgZGVsaW1pdGVyLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIHRocm93IG5ldyBDc3ZFcnJvcignQ1NWX0lOVkFMSURfT1BUSU9OX0RFTElNSVRFUicsIFtcbiAgICAgICAgICAnSW52YWxpZCBvcHRpb24gZGVsaW1pdGVyOicsXG4gICAgICAgICAgJ2RlbGltaXRlciBtdXN0IGJlIGEgbm9uIGVtcHR5IHN0cmluZyBvciBidWZmZXIgb3IgYXJyYXkgb2Ygc3RyaW5nfGJ1ZmZlciwnLFxuICAgICAgICAgIGBnb3QgJHtkZWxpbWl0ZXJfanNvbn1gXG4gICAgICAgIF0sIG9wdGlvbnMpXG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsaW1pdGVyXG4gICAgfSlcbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBlc2NhcGVgXG4gICAgaWYob3B0aW9ucy5lc2NhcGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmVzY2FwZSA9PT0gdHJ1ZSl7XG4gICAgICBvcHRpb25zLmVzY2FwZSA9IEJ1ZmZlci5mcm9tKCdcIicsIG9wdGlvbnMuZW5jb2RpbmcpXG4gICAgfWVsc2UgaWYodHlwZW9mIG9wdGlvbnMuZXNjYXBlID09PSAnc3RyaW5nJyl7XG4gICAgICBvcHRpb25zLmVzY2FwZSA9IEJ1ZmZlci5mcm9tKG9wdGlvbnMuZXNjYXBlLCBvcHRpb25zLmVuY29kaW5nKVxuICAgIH1lbHNlIGlmIChvcHRpb25zLmVzY2FwZSA9PT0gbnVsbCB8fCBvcHRpb25zLmVzY2FwZSA9PT0gZmFsc2Upe1xuICAgICAgb3B0aW9ucy5lc2NhcGUgPSBudWxsXG4gICAgfVxuICAgIGlmKG9wdGlvbnMuZXNjYXBlICE9PSBudWxsKXtcbiAgICAgIGlmKCFCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5lc2NhcGUpKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogZXNjYXBlIG11c3QgYmUgYSBidWZmZXIsIGEgc3RyaW5nIG9yIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5lc2NhcGUpfWApXG4gICAgICB9XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGZyb21gXG4gICAgaWYob3B0aW9ucy5mcm9tID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5mcm9tID09PSBudWxsKXtcbiAgICAgIG9wdGlvbnMuZnJvbSA9IDFcbiAgICB9ZWxzZXtcbiAgICAgIGlmKHR5cGVvZiBvcHRpb25zLmZyb20gPT09ICdzdHJpbmcnICYmIC9cXGQrLy50ZXN0KG9wdGlvbnMuZnJvbSkpe1xuICAgICAgICBvcHRpb25zLmZyb20gPSBwYXJzZUludChvcHRpb25zLmZyb20pXG4gICAgICB9XG4gICAgICBpZihOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMuZnJvbSkpe1xuICAgICAgICBpZihvcHRpb25zLmZyb20gPCAwKXtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBmcm9tIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRzLmZyb20pfWApXG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBmcm9tIG11c3QgYmUgYW4gaW50ZWdlciwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5mcm9tKX1gKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBmcm9tX2xpbmVgXG4gICAgaWYob3B0aW9ucy5mcm9tX2xpbmUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmZyb21fbGluZSA9PT0gbnVsbCl7XG4gICAgICBvcHRpb25zLmZyb21fbGluZSA9IDFcbiAgICB9ZWxzZXtcbiAgICAgIGlmKHR5cGVvZiBvcHRpb25zLmZyb21fbGluZSA9PT0gJ3N0cmluZycgJiYgL1xcZCsvLnRlc3Qob3B0aW9ucy5mcm9tX2xpbmUpKXtcbiAgICAgICAgb3B0aW9ucy5mcm9tX2xpbmUgPSBwYXJzZUludChvcHRpb25zLmZyb21fbGluZSlcbiAgICAgIH1cbiAgICAgIGlmKE51bWJlci5pc0ludGVnZXIob3B0aW9ucy5mcm9tX2xpbmUpKXtcbiAgICAgICAgaWYob3B0aW9ucy5mcm9tX2xpbmUgPD0gMCl7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogZnJvbV9saW5lIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRzLmZyb21fbGluZSl9YClcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IGZyb21fbGluZSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdHMuZnJvbV9saW5lKX1gKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9ucyBgaWdub3JlX2xhc3RfZGVsaW1pdGVyc2BcbiAgICBpZihvcHRpb25zLmlnbm9yZV9sYXN0X2RlbGltaXRlcnMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZV9sYXN0X2RlbGltaXRlcnMgPT09IG51bGwpe1xuICAgICAgb3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID0gZmFsc2VcbiAgICB9ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5pZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID09PSAnbnVtYmVyJyl7XG4gICAgICBvcHRpb25zLmlnbm9yZV9sYXN0X2RlbGltaXRlcnMgPSBNYXRoLmZsb29yKG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycylcbiAgICAgIGlmKG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyA9PT0gMCl7XG4gICAgICAgIG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyA9IGZhbHNlXG4gICAgICB9XG4gICAgfWVsc2UgaWYodHlwZW9mIG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyAhPT0gJ2Jvb2xlYW4nKXtcbiAgICAgIHRocm93IG5ldyBDc3ZFcnJvcignQ1NWX0lOVkFMSURfT1BUSU9OX0lHTk9SRV9MQVNUX0RFTElNSVRFUlMnLCBbXG4gICAgICAgICdJbnZhbGlkIG9wdGlvbiBgaWdub3JlX2xhc3RfZGVsaW1pdGVyc2A6JyxcbiAgICAgICAgJ3RoZSB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbiB2YWx1ZSBvciBhbiBpbnRlZ2VyLCcsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmlnbm9yZV9sYXN0X2RlbGltaXRlcnMpfWBcbiAgICAgIF0sIG9wdGlvbnMpXG4gICAgfVxuICAgIGlmKG9wdGlvbnMuaWdub3JlX2xhc3RfZGVsaW1pdGVycyA9PT0gdHJ1ZSAmJiBvcHRpb25zLmNvbHVtbnMgPT09IGZhbHNlKXtcbiAgICAgIHRocm93IG5ldyBDc3ZFcnJvcignQ1NWX0lHTk9SRV9MQVNUX0RFTElNSVRFUlNfUkVRVUlSRVNfQ09MVU1OUycsIFtcbiAgICAgICAgJ1RoZSBvcHRpb24gYGlnbm9yZV9sYXN0X2RlbGltaXRlcnNgJyxcbiAgICAgICAgJ3JlcXVpcmVzIHRoZSBhY3RpdmF0aW9uIG9mIHRoZSBgY29sdW1uc2Agb3B0aW9uJ1xuICAgICAgXSwgb3B0aW9ucylcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgaW5mb2BcbiAgICBpZihvcHRpb25zLmluZm8gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmluZm8gPT09IG51bGwgfHwgb3B0aW9ucy5pbmZvID09PSBmYWxzZSl7XG4gICAgICBvcHRpb25zLmluZm8gPSBmYWxzZVxuICAgIH1lbHNlIGlmKG9wdGlvbnMuaW5mbyAhPT0gdHJ1ZSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBpbmZvIG11c3QgYmUgdHJ1ZSwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5pbmZvKX1gKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBtYXhfcmVjb3JkX3NpemVgXG4gICAgaWYob3B0aW9ucy5tYXhfcmVjb3JkX3NpemUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSA9PT0gbnVsbCB8fCBvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSA9PT0gZmFsc2Upe1xuICAgICAgb3B0aW9ucy5tYXhfcmVjb3JkX3NpemUgPSAwXG4gICAgfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSkgJiYgb3B0aW9ucy5tYXhfcmVjb3JkX3NpemUgPj0gMCl7XG4gICAgICAvLyBHcmVhdCwgbm90aGluZyB0byBkb1xuICAgIH1lbHNlIGlmKHR5cGVvZiBvcHRpb25zLm1heF9yZWNvcmRfc2l6ZSA9PT0gJ3N0cmluZycgJiYgL1xcZCsvLnRlc3Qob3B0aW9ucy5tYXhfcmVjb3JkX3NpemUpKXtcbiAgICAgIG9wdGlvbnMubWF4X3JlY29yZF9zaXplID0gcGFyc2VJbnQob3B0aW9ucy5tYXhfcmVjb3JkX3NpemUpXG4gICAgfWVsc2V7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBtYXhfcmVjb3JkX3NpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMubWF4X3JlY29yZF9zaXplKX1gKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBvYmpuYW1lYFxuICAgIGlmKG9wdGlvbnMub2JqbmFtZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMub2JqbmFtZSA9PT0gbnVsbCB8fCBvcHRpb25zLm9iam5hbWUgPT09IGZhbHNlKXtcbiAgICAgIG9wdGlvbnMub2JqbmFtZSA9IHVuZGVmaW5lZFxuICAgIH1lbHNlIGlmKEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLm9iam5hbWUpKXtcbiAgICAgIGlmKG9wdGlvbnMub2JqbmFtZS5sZW5ndGggPT09IDApe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBvYmpuYW1lIG11c3QgYmUgYSBub24gZW1wdHkgYnVmZmVyYClcbiAgICAgIH1cbiAgICAgIGlmKG9wdGlvbnMuZW5jb2RpbmcgPT09IG51bGwpe1xuICAgICAgICAvLyBEb24ndCBjYWxsIGB0b1N0cmluZ2AsIGxlYXZlIG9iam5hbWUgYXMgYSBidWZmZXJcbiAgICAgIH1lbHNle1xuICAgICAgICBvcHRpb25zLm9iam5hbWUgPSBvcHRpb25zLm9iam5hbWUudG9TdHJpbmcob3B0aW9ucy5lbmNvZGluZylcbiAgICAgIH1cbiAgICB9ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5vYmpuYW1lID09PSAnc3RyaW5nJyl7XG4gICAgICBpZihvcHRpb25zLm9iam5hbWUubGVuZ3RoID09PSAwKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogb2JqbmFtZSBtdXN0IGJlIGEgbm9uIGVtcHR5IHN0cmluZ2ApXG4gICAgICB9XG4gICAgICAvLyBHcmVhdCwgbm90aGluZyB0byBkb1xuICAgIH1lbHNle1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogb2JqbmFtZSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgYnVmZmVyLCBnb3QgJHtvcHRpb25zLm9iam5hbWV9YClcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgb25fcmVjb3JkYFxuICAgIGlmKG9wdGlvbnMub25fcmVjb3JkID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5vbl9yZWNvcmQgPT09IG51bGwpe1xuICAgICAgb3B0aW9ucy5vbl9yZWNvcmQgPSB1bmRlZmluZWRcbiAgICB9ZWxzZSBpZih0eXBlb2Ygb3B0aW9ucy5vbl9yZWNvcmQgIT09ICdmdW5jdGlvbicpe1xuICAgICAgdGhyb3cgbmV3IENzdkVycm9yKCdDU1ZfSU5WQUxJRF9PUFRJT05fT05fUkVDT1JEJywgW1xuICAgICAgICAnSW52YWxpZCBvcHRpb24gYG9uX3JlY29yZGA6JyxcbiAgICAgICAgJ2V4cGVjdCBhIGZ1bmN0aW9uLCcsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLm9uX3JlY29yZCl9YFxuICAgICAgXSwgb3B0aW9ucylcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcXVvdGVgXG4gICAgaWYob3B0aW9ucy5xdW90ZSA9PT0gbnVsbCB8fCBvcHRpb25zLnF1b3RlID09PSBmYWxzZSB8fCBvcHRpb25zLnF1b3RlID09PSAnJyl7XG4gICAgICBvcHRpb25zLnF1b3RlID0gbnVsbFxuICAgIH1lbHNle1xuICAgICAgaWYob3B0aW9ucy5xdW90ZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucXVvdGUgPT09IHRydWUpe1xuICAgICAgICBvcHRpb25zLnF1b3RlID0gQnVmZmVyLmZyb20oJ1wiJywgb3B0aW9ucy5lbmNvZGluZylcbiAgICAgIH1lbHNlIGlmKHR5cGVvZiBvcHRpb25zLnF1b3RlID09PSAnc3RyaW5nJyl7XG4gICAgICAgIG9wdGlvbnMucXVvdGUgPSBCdWZmZXIuZnJvbShvcHRpb25zLnF1b3RlLCBvcHRpb25zLmVuY29kaW5nKVxuICAgICAgfVxuICAgICAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLnF1b3RlKSl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHF1b3RlIG11c3QgYmUgYSBidWZmZXIgb3IgYSBzdHJpbmcsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMucXVvdGUpfWApXG4gICAgICB9XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHJhd2BcbiAgICBpZihvcHRpb25zLnJhdyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucmF3ID09PSBudWxsIHx8IG9wdGlvbnMucmF3ID09PSBmYWxzZSl7XG4gICAgICBvcHRpb25zLnJhdyA9IGZhbHNlXG4gICAgfWVsc2UgaWYob3B0aW9ucy5yYXcgIT09IHRydWUpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogcmF3IG11c3QgYmUgdHJ1ZSwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5yYXcpfWApXG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHJlY29yZF9kZWxpbWl0ZXJgXG4gICAgaWYoIW9wdGlvbnMucmVjb3JkX2RlbGltaXRlcil7XG4gICAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBbXVxuICAgIH1lbHNlIGlmKCFBcnJheS5pc0FycmF5KG9wdGlvbnMucmVjb3JkX2RlbGltaXRlcikpe1xuICAgICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gW29wdGlvbnMucmVjb3JkX2RlbGltaXRlcl1cbiAgICB9XG4gICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyLm1hcCggZnVuY3Rpb24ocmQpe1xuICAgICAgaWYodHlwZW9mIHJkID09PSAnc3RyaW5nJyl7XG4gICAgICAgIHJkID0gQnVmZmVyLmZyb20ocmQsIG9wdGlvbnMuZW5jb2RpbmcpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmRcbiAgICB9KVxuICAgIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHJlbGF4YFxuICAgIGlmKHR5cGVvZiBvcHRpb25zLnJlbGF4ID09PSAnYm9vbGVhbicpe1xuICAgICAgLy8gR3JlYXQsIG5vdGhpbmcgdG8gZG9cbiAgICB9ZWxzZSBpZihvcHRpb25zLnJlbGF4ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5yZWxheCA9PT0gbnVsbCl7XG4gICAgICBvcHRpb25zLnJlbGF4ID0gZmFsc2VcbiAgICB9ZWxzZXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHJlbGF4IG11c3QgYmUgYSBib29sZWFuLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJlbGF4KX1gKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGByZWxheF9jb2x1bW5fY291bnRgXG4gICAgaWYodHlwZW9mIG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50ID09PSAnYm9vbGVhbicpe1xuICAgICAgLy8gR3JlYXQsIG5vdGhpbmcgdG8gZG9cbiAgICB9ZWxzZSBpZihvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50ID09PSBudWxsKXtcbiAgICAgIG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50ID0gZmFsc2VcbiAgICB9ZWxzZXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHJlbGF4X2NvbHVtbl9jb3VudCBtdXN0IGJlIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnQpfWApXG4gICAgfVxuICAgIGlmKHR5cGVvZiBvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9sZXNzID09PSAnYm9vbGVhbicpe1xuICAgICAgLy8gR3JlYXQsIG5vdGhpbmcgdG8gZG9cbiAgICB9ZWxzZSBpZihvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9sZXNzID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnRfbGVzcyA9PT0gbnVsbCl7XG4gICAgICBvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9sZXNzID0gZmFsc2VcbiAgICB9ZWxzZXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHJlbGF4X2NvbHVtbl9jb3VudF9sZXNzIG11c3QgYmUgYSBib29sZWFuLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJlbGF4X2NvbHVtbl9jb3VudF9sZXNzKX1gKVxuICAgIH1cbiAgICBpZih0eXBlb2Ygb3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnRfbW9yZSA9PT0gJ2Jvb2xlYW4nKXtcbiAgICAgIC8vIEdyZWF0LCBub3RoaW5nIHRvIGRvXG4gICAgfWVsc2UgaWYob3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnRfbW9yZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucmVsYXhfY29sdW1uX2NvdW50X21vcmUgPT09IG51bGwpe1xuICAgICAgb3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnRfbW9yZSA9IGZhbHNlXG4gICAgfWVsc2V7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiByZWxheF9jb2x1bW5fY291bnRfbW9yZSBtdXN0IGJlIGEgYm9vbGVhbiwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5yZWxheF9jb2x1bW5fY291bnRfbW9yZSl9YClcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgc2tpcF9lbXB0eV9saW5lc2BcbiAgICBpZih0eXBlb2Ygb3B0aW9ucy5za2lwX2VtcHR5X2xpbmVzID09PSAnYm9vbGVhbicpe1xuICAgICAgLy8gR3JlYXQsIG5vdGhpbmcgdG8gZG9cbiAgICB9ZWxzZSBpZihvcHRpb25zLnNraXBfZW1wdHlfbGluZXMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnNraXBfZW1wdHlfbGluZXMgPT09IG51bGwpe1xuICAgICAgb3B0aW9ucy5za2lwX2VtcHR5X2xpbmVzID0gZmFsc2VcbiAgICB9ZWxzZXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHNraXBfZW1wdHlfbGluZXMgbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuc2tpcF9lbXB0eV9saW5lcyl9YClcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgc2tpcF9saW5lc193aXRoX2VtcHR5X3ZhbHVlc2BcbiAgICBpZih0eXBlb2Ygb3B0aW9ucy5za2lwX2xpbmVzX3dpdGhfZW1wdHlfdmFsdWVzID09PSAnYm9vbGVhbicpe1xuICAgICAgLy8gR3JlYXQsIG5vdGhpbmcgdG8gZG9cbiAgICB9ZWxzZSBpZihvcHRpb25zLnNraXBfbGluZXNfd2l0aF9lbXB0eV92YWx1ZXMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnNraXBfbGluZXNfd2l0aF9lbXB0eV92YWx1ZXMgPT09IG51bGwpe1xuICAgICAgb3B0aW9ucy5za2lwX2xpbmVzX3dpdGhfZW1wdHlfdmFsdWVzID0gZmFsc2VcbiAgICB9ZWxzZXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHNraXBfbGluZXNfd2l0aF9lbXB0eV92YWx1ZXMgbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuc2tpcF9saW5lc193aXRoX2VtcHR5X3ZhbHVlcyl9YClcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgc2tpcF9saW5lc193aXRoX2Vycm9yYFxuICAgIGlmKHR5cGVvZiBvcHRpb25zLnNraXBfbGluZXNfd2l0aF9lcnJvciA9PT0gJ2Jvb2xlYW4nKXtcbiAgICAgIC8vIEdyZWF0LCBub3RoaW5nIHRvIGRvXG4gICAgfWVsc2UgaWYob3B0aW9ucy5za2lwX2xpbmVzX3dpdGhfZXJyb3IgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnNraXBfbGluZXNfd2l0aF9lcnJvciA9PT0gbnVsbCl7XG4gICAgICBvcHRpb25zLnNraXBfbGluZXNfd2l0aF9lcnJvciA9IGZhbHNlXG4gICAgfWVsc2V7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiBza2lwX2xpbmVzX3dpdGhfZXJyb3IgbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuc2tpcF9saW5lc193aXRoX2Vycm9yKX1gKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBydHJpbWBcbiAgICBpZihvcHRpb25zLnJ0cmltID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5ydHJpbSA9PT0gbnVsbCB8fCBvcHRpb25zLnJ0cmltID09PSBmYWxzZSl7XG4gICAgICBvcHRpb25zLnJ0cmltID0gZmFsc2VcbiAgICB9ZWxzZSBpZihvcHRpb25zLnJ0cmltICE9PSB0cnVlKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHJ0cmltIG11c3QgYmUgYSBib29sZWFuLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJ0cmltKX1gKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGBsdHJpbWBcbiAgICBpZihvcHRpb25zLmx0cmltID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5sdHJpbSA9PT0gbnVsbCB8fCBvcHRpb25zLmx0cmltID09PSBmYWxzZSl7XG4gICAgICBvcHRpb25zLmx0cmltID0gZmFsc2VcbiAgICB9ZWxzZSBpZihvcHRpb25zLmx0cmltICE9PSB0cnVlKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IGx0cmltIG11c3QgYmUgYSBib29sZWFuLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmx0cmltKX1gKVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGB0cmltYFxuICAgIGlmKG9wdGlvbnMudHJpbSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudHJpbSA9PT0gbnVsbCB8fCBvcHRpb25zLnRyaW0gPT09IGZhbHNlKXtcbiAgICAgIG9wdGlvbnMudHJpbSA9IGZhbHNlXG4gICAgfWVsc2UgaWYob3B0aW9ucy50cmltICE9PSB0cnVlKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHRyaW0gbXVzdCBiZSBhIGJvb2xlYW4sIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMudHJpbSl9YClcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbnMgYHRyaW1gLCBgbHRyaW1gIGFuZCBgcnRyaW1gXG4gICAgaWYob3B0aW9ucy50cmltID09PSB0cnVlICYmIG9wdHMubHRyaW0gIT09IGZhbHNlKXtcbiAgICAgIG9wdGlvbnMubHRyaW0gPSB0cnVlXG4gICAgfWVsc2UgaWYob3B0aW9ucy5sdHJpbSAhPT0gdHJ1ZSl7XG4gICAgICBvcHRpb25zLmx0cmltID0gZmFsc2VcbiAgICB9XG4gICAgaWYob3B0aW9ucy50cmltID09PSB0cnVlICYmIG9wdHMucnRyaW0gIT09IGZhbHNlKXtcbiAgICAgIG9wdGlvbnMucnRyaW0gPSB0cnVlXG4gICAgfWVsc2UgaWYob3B0aW9ucy5ydHJpbSAhPT0gdHJ1ZSl7XG4gICAgICBvcHRpb25zLnJ0cmltID0gZmFsc2VcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbiBgdG9gXG4gICAgaWYob3B0aW9ucy50byA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudG8gPT09IG51bGwpe1xuICAgICAgb3B0aW9ucy50byA9IC0xXG4gICAgfWVsc2V7XG4gICAgICBpZih0eXBlb2Ygb3B0aW9ucy50byA9PT0gJ3N0cmluZycgJiYgL1xcZCsvLnRlc3Qob3B0aW9ucy50bykpe1xuICAgICAgICBvcHRpb25zLnRvID0gcGFyc2VJbnQob3B0aW9ucy50bylcbiAgICAgIH1cbiAgICAgIGlmKE51bWJlci5pc0ludGVnZXIob3B0aW9ucy50bykpe1xuICAgICAgICBpZihvcHRpb25zLnRvIDw9IDApe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBPcHRpb246IHRvIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRzLnRvKX1gKVxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE9wdGlvbjogdG8gbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRzLnRvKX1gKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3B0aW9uIGB0b19saW5lYFxuICAgIGlmKG9wdGlvbnMudG9fbGluZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudG9fbGluZSA9PT0gbnVsbCl7XG4gICAgICBvcHRpb25zLnRvX2xpbmUgPSAtMVxuICAgIH1lbHNle1xuICAgICAgaWYodHlwZW9mIG9wdGlvbnMudG9fbGluZSA9PT0gJ3N0cmluZycgJiYgL1xcZCsvLnRlc3Qob3B0aW9ucy50b19saW5lKSl7XG4gICAgICAgIG9wdGlvbnMudG9fbGluZSA9IHBhcnNlSW50KG9wdGlvbnMudG9fbGluZSlcbiAgICAgIH1cbiAgICAgIGlmKE51bWJlci5pc0ludGVnZXIob3B0aW9ucy50b19saW5lKSl7XG4gICAgICAgIGlmKG9wdGlvbnMudG9fbGluZSA8PSAwKXtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiB0b19saW5lIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRzLnRvX2xpbmUpfWApXG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgT3B0aW9uOiB0b19saW5lIG11c3QgYmUgYW4gaW50ZWdlciwgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0cy50b19saW5lKX1gKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmluZm8gPSB7XG4gICAgICBieXRlczogMCxcbiAgICAgIGNvbW1lbnRfbGluZXM6IDAsXG4gICAgICBlbXB0eV9saW5lczogMCxcbiAgICAgIGludmFsaWRfZmllbGRfbGVuZ3RoOiAwLFxuICAgICAgbGluZXM6IDEsXG4gICAgICByZWNvcmRzOiAwXG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgYm9tU2tpcHBlZDogZmFsc2UsXG4gICAgICBidWZCeXRlc1N0YXJ0OiAwLFxuICAgICAgY2FzdEZpZWxkOiBmbkNhc3RGaWVsZCxcbiAgICAgIGNvbW1lbnRpbmc6IGZhbHNlLFxuICAgICAgLy8gQ3VycmVudCBlcnJvciBlbmNvdW50ZXJlZCBieSBhIHJlY29yZFxuICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgIGVuYWJsZWQ6IG9wdGlvbnMuZnJvbV9saW5lID09PSAxLFxuICAgICAgZXNjYXBpbmc6IGZhbHNlLFxuICAgICAgLy8gZXNjYXBlSXNRdW90ZTogb3B0aW9ucy5lc2NhcGUgPT09IG9wdGlvbnMucXVvdGUsXG4gICAgICBlc2NhcGVJc1F1b3RlOiBCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5lc2NhcGUpICYmIEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLnF1b3RlKSAmJiBCdWZmZXIuY29tcGFyZShvcHRpb25zLmVzY2FwZSwgb3B0aW9ucy5xdW90ZSkgPT09IDAsXG4gICAgICAvLyBjb2x1bW5zIGNhbiBiZSBgZmFsc2VgLCBgdHJ1ZWAsIGBBcnJheWBcbiAgICAgIGV4cGVjdGVkUmVjb3JkTGVuZ3RoOiBBcnJheS5pc0FycmF5KG9wdGlvbnMuY29sdW1ucykgPyBvcHRpb25zLmNvbHVtbnMubGVuZ3RoIDogdW5kZWZpbmVkLFxuICAgICAgZmllbGQ6IG5ldyBSZXNpemVhYmxlQnVmZmVyKDIwKSxcbiAgICAgIGZpcnN0TGluZVRvSGVhZGVyczogZm5GaXJzdExpbmVUb0hlYWRlcnMsXG4gICAgICBuZWVkTW9yZURhdGFTaXplOiBNYXRoLm1heChcbiAgICAgICAgLy8gU2tpcCBpZiB0aGUgcmVtYWluaW5nIGJ1ZmZlciBzbWFsbGVyIHRoYW4gY29tbWVudFxuICAgICAgICBvcHRpb25zLmNvbW1lbnQgIT09IG51bGwgPyBvcHRpb25zLmNvbW1lbnQubGVuZ3RoIDogMCxcbiAgICAgICAgLy8gU2tpcCBpZiB0aGUgcmVtYWluaW5nIGJ1ZmZlciBjYW4gYmUgZGVsaW1pdGVyXG4gICAgICAgIC4uLm9wdGlvbnMuZGVsaW1pdGVyLm1hcCggKGRlbGltaXRlcikgPT4gZGVsaW1pdGVyLmxlbmd0aCksXG4gICAgICAgIC8vIFNraXAgaWYgdGhlIHJlbWFpbmluZyBidWZmZXIgY2FuIGJlIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICBvcHRpb25zLnF1b3RlICE9PSBudWxsID8gb3B0aW9ucy5xdW90ZS5sZW5ndGggOiAwLFxuICAgICAgKSxcbiAgICAgIHByZXZpb3VzQnVmOiB1bmRlZmluZWQsXG4gICAgICBxdW90aW5nOiBmYWxzZSxcbiAgICAgIHN0b3A6IGZhbHNlLFxuICAgICAgcmF3QnVmZmVyOiBuZXcgUmVzaXplYWJsZUJ1ZmZlcigxMDApLFxuICAgICAgcmVjb3JkOiBbXSxcbiAgICAgIHJlY29yZEhhc0Vycm9yOiBmYWxzZSxcbiAgICAgIHJlY29yZF9sZW5ndGg6IDAsXG4gICAgICByZWNvcmREZWxpbWl0ZXJNYXhMZW5ndGg6IG9wdGlvbnMucmVjb3JkX2RlbGltaXRlci5sZW5ndGggPT09IDAgPyAyIDogTWF0aC5tYXgoLi4ub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyLm1hcCggKHYpID0+IHYubGVuZ3RoKSksXG4gICAgICB0cmltQ2hhcnM6IFtCdWZmZXIuZnJvbSgnICcsIG9wdGlvbnMuZW5jb2RpbmcpWzBdLCBCdWZmZXIuZnJvbSgnXFx0Jywgb3B0aW9ucy5lbmNvZGluZylbMF1dLFxuICAgICAgd2FzUXVvdGluZzogZmFsc2UsXG4gICAgICB3YXNSb3dEZWxpbWl0ZXI6IGZhbHNlXG4gICAgfVxuICB9XG4gIC8vIEltcGxlbWVudGF0aW9uIG9mIGBUcmFuc2Zvcm0uX3RyYW5zZm9ybWBcbiAgX3RyYW5zZm9ybShidWYsIGVuY29kaW5nLCBjYWxsYmFjayl7XG4gICAgaWYodGhpcy5zdGF0ZS5zdG9wID09PSB0cnVlKXtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBlcnIgPSB0aGlzLl9fcGFyc2UoYnVmLCBmYWxzZSlcbiAgICBpZihlcnIgIT09IHVuZGVmaW5lZCl7XG4gICAgICB0aGlzLnN0YXRlLnN0b3AgPSB0cnVlXG4gICAgfVxuICAgIGNhbGxiYWNrKGVycilcbiAgfVxuICAvLyBJbXBsZW1lbnRhdGlvbiBvZiBgVHJhbnNmb3JtLl9mbHVzaGBcbiAgX2ZsdXNoKGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLnN0YXRlLnN0b3AgPT09IHRydWUpe1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IGVyciA9IHRoaXMuX19wYXJzZSh1bmRlZmluZWQsIHRydWUpXG4gICAgY2FsbGJhY2soZXJyKVxuICB9XG4gIC8vIENlbnRyYWwgcGFyc2VyIGltcGxlbWVudGF0aW9uXG4gIF9fcGFyc2UobmV4dEJ1ZiwgZW5kKXtcbiAgICBjb25zdCB7Ym9tLCBjb21tZW50LCBlc2NhcGUsIGZyb21fbGluZSwgbHRyaW0sIG1heF9yZWNvcmRfc2l6ZSwgcXVvdGUsIHJhdywgcmVsYXgsIHJ0cmltLCBza2lwX2VtcHR5X2xpbmVzLCB0bywgdG9fbGluZX0gPSB0aGlzLm9wdGlvbnNcbiAgICBsZXQge3JlY29yZF9kZWxpbWl0ZXJ9ID0gdGhpcy5vcHRpb25zXG4gICAgY29uc3Qge2JvbVNraXBwZWQsIHByZXZpb3VzQnVmLCByYXdCdWZmZXIsIGVzY2FwZUlzUXVvdGV9ID0gdGhpcy5zdGF0ZVxuICAgIGxldCBidWZcbiAgICBpZihwcmV2aW91c0J1ZiA9PT0gdW5kZWZpbmVkKXtcbiAgICAgIGlmKG5leHRCdWYgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgIC8vIEhhbmRsZSBlbXB0eSBzdHJpbmdcbiAgICAgICAgdGhpcy5wdXNoKG51bGwpXG4gICAgICAgIHJldHVyblxuICAgICAgfWVsc2V7XG4gICAgICAgIGJ1ZiA9IG5leHRCdWZcbiAgICAgIH1cbiAgICB9ZWxzZSBpZihwcmV2aW91c0J1ZiAhPT0gdW5kZWZpbmVkICYmIG5leHRCdWYgPT09IHVuZGVmaW5lZCl7XG4gICAgICBidWYgPSBwcmV2aW91c0J1ZlxuICAgIH1lbHNle1xuICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChbcHJldmlvdXNCdWYsIG5leHRCdWZdKVxuICAgIH1cbiAgICAvLyBIYW5kbGUgVVRGIEJPTVxuICAgIGlmKGJvbVNraXBwZWQgPT09IGZhbHNlKXtcbiAgICAgIGlmKGJvbSA9PT0gZmFsc2Upe1xuICAgICAgICB0aGlzLnN0YXRlLmJvbVNraXBwZWQgPSB0cnVlXG4gICAgICB9ZWxzZSBpZihidWYubGVuZ3RoIDwgMyl7XG4gICAgICAgIC8vIE5vIGVub3VnaCBkYXRhXG4gICAgICAgIGlmKGVuZCA9PT0gZmFsc2Upe1xuICAgICAgICAgIC8vIFdhaXQgZm9yIG1vcmUgZGF0YVxuICAgICAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNCdWYgPSBidWZcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIGZvcihsZXQgZW5jb2RpbmcgaW4gYm9tcyl7XG4gICAgICAgICAgaWYoYm9tc1tlbmNvZGluZ10uY29tcGFyZShidWYsIDAsIGJvbXNbZW5jb2RpbmddLmxlbmd0aCkgPT09IDApe1xuICAgICAgICAgICAgLy8gU2tpcCBCT01cbiAgICAgICAgICAgIGxldCBib21MZW5ndGggPSBib21zW2VuY29kaW5nXS5sZW5ndGhcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuYnVmQnl0ZXNTdGFydCArPSBib21MZW5ndGhcbiAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5zbGljZShib21MZW5ndGgpXG4gICAgICAgICAgICAvLyBSZW5vcm1hbGl6ZSBvcmlnaW5hbCBvcHRpb25zIHdpdGggdGhlIG5ldyBlbmNvZGluZ1xuICAgICAgICAgICAgdGhpcy5fX25vcm1hbGl6ZU9wdGlvbnMoey4uLnRoaXMuX19vcmlnaW5hbE9wdGlvbnMsIGVuY29kaW5nOiBlbmNvZGluZ30pXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLmJvbVNraXBwZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJ1ZkxlbiA9IGJ1Zi5sZW5ndGhcbiAgICBsZXQgcG9zXG4gICAgZm9yKHBvcyA9IDA7IHBvcyA8IGJ1ZkxlbjsgcG9zKyspe1xuICAgICAgLy8gRW5zdXJlIHdlIGdldCBlbm91Z2ggc3BhY2UgdG8gbG9vayBhaGVhZFxuICAgICAgLy8gVGhlcmUgc2hvdWxkIGJlIGEgd2F5IHRvIG1vdmUgdGhpcyBvdXQgb2YgdGhlIGxvb3BcbiAgICAgIGlmKHRoaXMuX19uZWVkTW9yZURhdGEocG9zLCBidWZMZW4sIGVuZCkpe1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYodGhpcy5zdGF0ZS53YXNSb3dEZWxpbWl0ZXIgPT09IHRydWUpe1xuICAgICAgICB0aGlzLmluZm8ubGluZXMrK1xuICAgICAgICB0aGlzLnN0YXRlLndhc1Jvd0RlbGltaXRlciA9IGZhbHNlXG4gICAgICB9XG4gICAgICBpZih0b19saW5lICE9PSAtMSAmJiB0aGlzLmluZm8ubGluZXMgPiB0b19saW5lKXtcbiAgICAgICAgdGhpcy5zdGF0ZS5zdG9wID0gdHJ1ZVxuICAgICAgICB0aGlzLnB1c2gobnVsbClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBBdXRvIGRpc2NvdmVyeSBvZiByZWNvcmRfZGVsaW1pdGVyLCB1bml4LCBtYWMgYW5kIHdpbmRvd3Mgc3VwcG9ydGVkXG4gICAgICBpZih0aGlzLnN0YXRlLnF1b3RpbmcgPT09IGZhbHNlICYmIHJlY29yZF9kZWxpbWl0ZXIubGVuZ3RoID09PSAwKXtcbiAgICAgICAgY29uc3QgcmVjb3JkX2RlbGltaXRlckNvdW50ID0gdGhpcy5fX2F1dG9EaXNjb3ZlclJlY29yZERlbGltaXRlcihidWYsIHBvcylcbiAgICAgICAgaWYocmVjb3JkX2RlbGltaXRlckNvdW50KXtcbiAgICAgICAgICByZWNvcmRfZGVsaW1pdGVyID0gdGhpcy5vcHRpb25zLnJlY29yZF9kZWxpbWl0ZXJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2hyID0gYnVmW3Bvc11cbiAgICAgIGlmKHJhdyA9PT0gdHJ1ZSl7XG4gICAgICAgIHJhd0J1ZmZlci5hcHBlbmQoY2hyKVxuICAgICAgfVxuICAgICAgaWYoKGNociA9PT0gY3IgfHwgY2hyID09PSBubCkgJiYgdGhpcy5zdGF0ZS53YXNSb3dEZWxpbWl0ZXIgPT09IGZhbHNlICl7XG4gICAgICAgIHRoaXMuc3RhdGUud2FzUm93RGVsaW1pdGVyID0gdHJ1ZVxuICAgICAgfVxuICAgICAgLy8gUHJldmlvdXMgY2hhciB3YXMgYSB2YWxpZCBlc2NhcGUgY2hhclxuICAgICAgLy8gdHJlYXQgdGhlIGN1cnJlbnQgY2hhciBhcyBhIHJlZ3VsYXIgY2hhclxuICAgICAgaWYodGhpcy5zdGF0ZS5lc2NhcGluZyA9PT0gdHJ1ZSl7XG4gICAgICAgIHRoaXMuc3RhdGUuZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgfWVsc2V7XG4gICAgICAgIC8vIEVzY2FwZSBpcyBvbmx5IGFjdGl2ZSBpbnNpZGUgcXVvdGVkIGZpZWxkc1xuICAgICAgICAvLyBXZSBhcmUgcXVvdGluZywgdGhlIGNoYXIgaXMgYW4gZXNjYXBlIGNociBhbmQgdGhlcmUgaXMgYSBjaHIgdG8gZXNjYXBlXG4gICAgICAgIC8vIGlmKGVzY2FwZSAhPT0gbnVsbCAmJiB0aGlzLnN0YXRlLnF1b3RpbmcgPT09IHRydWUgJiYgY2hyID09PSBlc2NhcGUgJiYgcG9zICsgMSA8IGJ1Zkxlbil7XG4gICAgICAgIGlmKGVzY2FwZSAhPT0gbnVsbCAmJiB0aGlzLnN0YXRlLnF1b3RpbmcgPT09IHRydWUgJiYgdGhpcy5fX2lzRXNjYXBlKGJ1ZiwgcG9zLCBjaHIpICYmIHBvcyArIGVzY2FwZS5sZW5ndGggPCBidWZMZW4pe1xuICAgICAgICAgIGlmKGVzY2FwZUlzUXVvdGUpe1xuICAgICAgICAgICAgaWYodGhpcy5fX2lzUXVvdGUoYnVmLCBwb3MrZXNjYXBlLmxlbmd0aCkpe1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlLmVzY2FwaW5nID0gdHJ1ZVxuICAgICAgICAgICAgICBwb3MgKz0gZXNjYXBlLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZXNjYXBpbmcgPSB0cnVlXG4gICAgICAgICAgICBwb3MgKz0gZXNjYXBlLmxlbmd0aCAtIDFcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCBjdXJyZW50bHkgZXNjYXBpbmcgYW5kIGNociBpcyBhIHF1b3RlXG4gICAgICAgIC8vIFRPRE86IG5lZWQgdG8gY29tcGFyZSBieXRlcyBpbnN0ZWFkIG9mIHNpbmdsZSBjaGFyXG4gICAgICAgIGlmKHRoaXMuc3RhdGUuY29tbWVudGluZyA9PT0gZmFsc2UgJiYgdGhpcy5fX2lzUXVvdGUoYnVmLCBwb3MpKXtcbiAgICAgICAgICBpZih0aGlzLnN0YXRlLnF1b3RpbmcgPT09IHRydWUpe1xuICAgICAgICAgICAgY29uc3QgbmV4dENociA9IGJ1Zltwb3MrcXVvdGUubGVuZ3RoXVxuICAgICAgICAgICAgY29uc3QgaXNOZXh0Q2hyVHJpbWFibGUgPSBydHJpbSAmJiB0aGlzLl9faXNDaGFyVHJpbWFibGUobmV4dENocilcbiAgICAgICAgICAgIGNvbnN0IGlzTmV4dENockNvbW1lbnQgPSBjb21tZW50ICE9PSBudWxsICYmIHRoaXMuX19jb21wYXJlQnl0ZXMoY29tbWVudCwgYnVmLCBwb3MrcXVvdGUubGVuZ3RoLCBuZXh0Q2hyKVxuICAgICAgICAgICAgY29uc3QgaXNOZXh0Q2hyRGVsaW1pdGVyID0gdGhpcy5fX2lzRGVsaW1pdGVyKGJ1ZiwgcG9zK3F1b3RlLmxlbmd0aCwgbmV4dENocilcbiAgICAgICAgICAgIGNvbnN0IGlzTmV4dENoclJlY29yZERlbGltaXRlciA9IHJlY29yZF9kZWxpbWl0ZXIubGVuZ3RoID09PSAwID8gdGhpcy5fX2F1dG9EaXNjb3ZlclJlY29yZERlbGltaXRlcihidWYsIHBvcytxdW90ZS5sZW5ndGgpIDogdGhpcy5fX2lzUmVjb3JkRGVsaW1pdGVyKG5leHRDaHIsIGJ1ZiwgcG9zK3F1b3RlLmxlbmd0aClcbiAgICAgICAgICAgIC8vIEVzY2FwZSBhIHF1b3RlXG4gICAgICAgICAgICAvLyBUcmVhdCBuZXh0IGNoYXIgYXMgYSByZWd1bGFyIGNoYXJhY3RlclxuICAgICAgICAgICAgaWYoZXNjYXBlICE9PSBudWxsICYmIHRoaXMuX19pc0VzY2FwZShidWYsIHBvcywgY2hyKSAmJiB0aGlzLl9faXNRdW90ZShidWYsIHBvcyArIGVzY2FwZS5sZW5ndGgpKXtcbiAgICAgICAgICAgICAgcG9zICs9IGVzY2FwZS5sZW5ndGggLSAxXG4gICAgICAgICAgICB9ZWxzZSBpZighbmV4dENociB8fCBpc05leHRDaHJEZWxpbWl0ZXIgfHwgaXNOZXh0Q2hyUmVjb3JkRGVsaW1pdGVyIHx8IGlzTmV4dENockNvbW1lbnQgfHwgaXNOZXh0Q2hyVHJpbWFibGUpe1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlLnF1b3RpbmcgPSBmYWxzZVxuICAgICAgICAgICAgICB0aGlzLnN0YXRlLndhc1F1b3RpbmcgPSB0cnVlXG4gICAgICAgICAgICAgIHBvcyArPSBxdW90ZS5sZW5ndGggLSAxXG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9ZWxzZSBpZihyZWxheCA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fZXJyb3IoXG4gICAgICAgICAgICAgICAgbmV3IENzdkVycm9yKCdDU1ZfSU5WQUxJRF9DTE9TSU5HX1FVT1RFJywgW1xuICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgQ2xvc2luZyBRdW90ZTonLFxuICAgICAgICAgICAgICAgICAgYGdvdCBcIiR7U3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hyKX1cImAsXG4gICAgICAgICAgICAgICAgICBgYXQgbGluZSAke3RoaXMuaW5mby5saW5lc31gLFxuICAgICAgICAgICAgICAgICAgJ2luc3RlYWQgb2YgZGVsaW1pdGVyLCByZWNvcmQgZGVsaW1pdGVyLCB0cmltYWJsZSBjaGFyYWN0ZXInLFxuICAgICAgICAgICAgICAgICAgJyhpZiBhY3RpdmF0ZWQpIG9yIGNvbW1lbnQnLFxuICAgICAgICAgICAgICAgIF0sIHRoaXMub3B0aW9ucywgdGhpcy5fX2luZm9GaWVsZCgpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIGlmKGVyciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5xdW90aW5nID0gZmFsc2VcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZS53YXNRdW90aW5nID0gdHJ1ZVxuICAgICAgICAgICAgICB0aGlzLnN0YXRlLmZpZWxkLnByZXBlbmQocXVvdGUpXG4gICAgICAgICAgICAgIHBvcyArPSBxdW90ZS5sZW5ndGggLSAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBpZih0aGlzLnN0YXRlLmZpZWxkLmxlbmd0aCAhPT0gMCl7XG4gICAgICAgICAgICAgIC8vIEluIHJlbGF4IG1vZGUsIHRyZWF0IG9wZW5pbmcgcXVvdGUgcHJlY2VkZWQgYnkgY2hycyBhcyByZWd1bGFyXG4gICAgICAgICAgICAgIGlmKCByZWxheCA9PT0gZmFsc2UgKXtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fZXJyb3IoXG4gICAgICAgICAgICAgICAgICBuZXcgQ3N2RXJyb3IoJ0lOVkFMSURfT1BFTklOR19RVU9URScsIFtcbiAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgT3BlbmluZyBRdW90ZTonLFxuICAgICAgICAgICAgICAgICAgICBgYSBxdW90ZSBpcyBmb3VuZCBpbnNpZGUgYSBmaWVsZCBhdCBsaW5lICR7dGhpcy5pbmZvLmxpbmVzfWAsXG4gICAgICAgICAgICAgICAgICBdLCB0aGlzLm9wdGlvbnMsIHRoaXMuX19pbmZvRmllbGQoKSwge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogdGhpcy5zdGF0ZS5maWVsZCxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGlmKGVyciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlLnF1b3RpbmcgPSB0cnVlXG4gICAgICAgICAgICAgIHBvcyArPSBxdW90ZS5sZW5ndGggLSAxXG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuc3RhdGUucXVvdGluZyA9PT0gZmFsc2Upe1xuICAgICAgICAgIGxldCByZWNvcmREZWxpbWl0ZXJMZW5ndGggPSB0aGlzLl9faXNSZWNvcmREZWxpbWl0ZXIoY2hyLCBidWYsIHBvcylcbiAgICAgICAgICBpZihyZWNvcmREZWxpbWl0ZXJMZW5ndGggIT09IDApe1xuICAgICAgICAgICAgLy8gRG8gbm90IGVtaXQgY29tbWVudHMgd2hpY2ggdGFrZSBhIGZ1bGwgbGluZVxuICAgICAgICAgICAgY29uc3Qgc2tpcENvbW1lbnRMaW5lID0gdGhpcy5zdGF0ZS5jb21tZW50aW5nICYmICh0aGlzLnN0YXRlLndhc1F1b3RpbmcgPT09IGZhbHNlICYmIHRoaXMuc3RhdGUucmVjb3JkLmxlbmd0aCA9PT0gMCAmJiB0aGlzLnN0YXRlLmZpZWxkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIGlmKHNraXBDb21tZW50TGluZSl7XG4gICAgICAgICAgICAgIHRoaXMuaW5mby5jb21tZW50X2xpbmVzKytcbiAgICAgICAgICAgICAgLy8gU2tpcCBmdWxsIGNvbW1lbnQgbGluZVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIC8vIEFjdGl2YXRlIHJlY29yZHMgZW1pdGlvbiBpZiBhYm92ZSBmcm9tX2xpbmVcbiAgICAgICAgICAgICAgaWYodGhpcy5zdGF0ZS5lbmFibGVkID09PSBmYWxzZSAmJiB0aGlzLmluZm8ubGluZXMgKyAodGhpcy5zdGF0ZS53YXNSb3dEZWxpbWl0ZXIgPT09IHRydWUgPyAxOiAwKSA+PSBmcm9tX2xpbmUpe1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZW5hYmxlZCA9IHRydWVcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVzZXRGaWVsZCgpXG4gICAgICAgICAgICAgICAgdGhpcy5fX3Jlc2V0UmVjb3JkKClcbiAgICAgICAgICAgICAgICBwb3MgKz0gcmVjb3JkRGVsaW1pdGVyTGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gU2tpcCBpZiBsaW5lIGlzIGVtcHR5IGFuZCBza2lwX2VtcHR5X2xpbmVzIGFjdGl2YXRlZFxuICAgICAgICAgICAgICBpZihza2lwX2VtcHR5X2xpbmVzID09PSB0cnVlICYmIHRoaXMuc3RhdGUud2FzUXVvdGluZyA9PT0gZmFsc2UgJiYgdGhpcy5zdGF0ZS5yZWNvcmQubGVuZ3RoID09PSAwICYmIHRoaXMuc3RhdGUuZmllbGQubGVuZ3RoID09PSAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uZW1wdHlfbGluZXMrK1xuICAgICAgICAgICAgICAgIHBvcyArPSByZWNvcmREZWxpbWl0ZXJMZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmluZm8uYnl0ZXMgPSB0aGlzLnN0YXRlLmJ1ZkJ5dGVzU3RhcnQgKyBwb3M7XG4gICAgICAgICAgICAgIGNvbnN0IGVyckZpZWxkID0gdGhpcy5fX29uRmllbGQoKVxuICAgICAgICAgICAgICBpZihlcnJGaWVsZCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyRmllbGRcbiAgICAgICAgICAgICAgdGhpcy5pbmZvLmJ5dGVzID0gdGhpcy5zdGF0ZS5idWZCeXRlc1N0YXJ0ICsgcG9zICsgcmVjb3JkRGVsaW1pdGVyTGVuZ3RoO1xuICAgICAgICAgICAgICBjb25zdCBlcnJSZWNvcmQgPSB0aGlzLl9fb25SZWNvcmQoKVxuICAgICAgICAgICAgICBpZihlcnJSZWNvcmQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGVyclJlY29yZFxuICAgICAgICAgICAgICBpZih0byAhPT0gLTEgJiYgdGhpcy5pbmZvLnJlY29yZHMgPj0gdG8pe1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RvcCA9IHRydWVcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2gobnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jb21tZW50aW5nID0gZmFsc2VcbiAgICAgICAgICAgIHBvcyArPSByZWNvcmREZWxpbWl0ZXJMZW5ndGggLSAxXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0aGlzLnN0YXRlLmNvbW1lbnRpbmcpe1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29tbWVudENvdW50ID0gY29tbWVudCA9PT0gbnVsbCA/IDAgOiB0aGlzLl9fY29tcGFyZUJ5dGVzKGNvbW1lbnQsIGJ1ZiwgcG9zLCBjaHIpXG4gICAgICAgICAgaWYoY29tbWVudENvdW50ICE9PSAwKXtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY29tbWVudGluZyA9IHRydWVcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBkZWxpbWl0ZXJMZW5ndGggPSB0aGlzLl9faXNEZWxpbWl0ZXIoYnVmLCBwb3MsIGNocilcbiAgICAgICAgICBpZihkZWxpbWl0ZXJMZW5ndGggIT09IDApe1xuICAgICAgICAgICAgdGhpcy5pbmZvLmJ5dGVzID0gdGhpcy5zdGF0ZS5idWZCeXRlc1N0YXJ0ICsgcG9zO1xuICAgICAgICAgICAgY29uc3QgZXJyRmllbGQgPSB0aGlzLl9fb25GaWVsZCgpXG4gICAgICAgICAgICBpZihlcnJGaWVsZCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyRmllbGRcbiAgICAgICAgICAgIHBvcyArPSBkZWxpbWl0ZXJMZW5ndGggLSAxXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYodGhpcy5zdGF0ZS5jb21tZW50aW5nID09PSBmYWxzZSl7XG4gICAgICAgIGlmKG1heF9yZWNvcmRfc2l6ZSAhPT0gMCAmJiB0aGlzLnN0YXRlLnJlY29yZF9sZW5ndGggKyB0aGlzLnN0YXRlLmZpZWxkLmxlbmd0aCA+IG1heF9yZWNvcmRfc2l6ZSl7XG4gICAgICAgICAgY29uc3QgZXJyID0gdGhpcy5fX2Vycm9yKFxuICAgICAgICAgICAgbmV3IENzdkVycm9yKCdDU1ZfTUFYX1JFQ09SRF9TSVpFJywgW1xuICAgICAgICAgICAgICAnTWF4IFJlY29yZCBTaXplOicsXG4gICAgICAgICAgICAgICdyZWNvcmQgZXhjZWVkIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0b2xlcmF0ZWQgYnl0ZXMnLFxuICAgICAgICAgICAgICBgb2YgJHttYXhfcmVjb3JkX3NpemV9YCxcbiAgICAgICAgICAgICAgYGF0IGxpbmUgJHt0aGlzLmluZm8ubGluZXN9YCxcbiAgICAgICAgICAgIF0sIHRoaXMub3B0aW9ucywgdGhpcy5fX2luZm9GaWVsZCgpKVxuICAgICAgICAgIClcbiAgICAgICAgICBpZihlcnIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGVyclxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBsYXBwZW5kID0gbHRyaW0gPT09IGZhbHNlIHx8IHRoaXMuc3RhdGUucXVvdGluZyA9PT0gdHJ1ZSB8fCB0aGlzLnN0YXRlLmZpZWxkLmxlbmd0aCAhPT0gMCB8fCAhdGhpcy5fX2lzQ2hhclRyaW1hYmxlKGNocilcbiAgICAgIC8vIHJ0cmltIGluIG5vbiBxdW90aW5nIGlzIGhhbmRsZSBpbiBfX29uRmllbGRcbiAgICAgIGNvbnN0IHJhcHBlbmQgPSBydHJpbSA9PT0gZmFsc2UgfHwgdGhpcy5zdGF0ZS53YXNRdW90aW5nID09PSBmYWxzZVxuICAgICAgaWYoIGxhcHBlbmQgPT09IHRydWUgJiYgcmFwcGVuZCA9PT0gdHJ1ZSApe1xuICAgICAgICB0aGlzLnN0YXRlLmZpZWxkLmFwcGVuZChjaHIpXG4gICAgICB9ZWxzZSBpZihydHJpbSA9PT0gdHJ1ZSAmJiAhdGhpcy5fX2lzQ2hhclRyaW1hYmxlKGNocikpe1xuICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fZXJyb3IoXG4gICAgICAgICAgbmV3IENzdkVycm9yKCdDU1ZfTk9OX1RSSU1BQkxFX0NIQVJfQUZURVJfQ0xPU0lOR19RVU9URScsIFtcbiAgICAgICAgICAgICdJbnZhbGlkIENsb3NpbmcgUXVvdGU6JyxcbiAgICAgICAgICAgICdmb3VuZCBub24gdHJpbWFibGUgYnl0ZSBhZnRlciBxdW90ZScsXG4gICAgICAgICAgICBgYXQgbGluZSAke3RoaXMuaW5mby5saW5lc31gLFxuICAgICAgICAgIF0sIHRoaXMub3B0aW9ucywgdGhpcy5fX2luZm9GaWVsZCgpKVxuICAgICAgICApXG4gICAgICAgIGlmKGVyciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyXG4gICAgICB9XG4gICAgfVxuICAgIGlmKGVuZCA9PT0gdHJ1ZSl7XG4gICAgICAvLyBFbnN1cmUgd2UgYXJlIG5vdCBlbmRpbmcgaW4gYSBxdW90aW5nIHN0YXRlXG4gICAgICBpZih0aGlzLnN0YXRlLnF1b3RpbmcgPT09IHRydWUpe1xuICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fZXJyb3IoXG4gICAgICAgICAgbmV3IENzdkVycm9yKCdDU1ZfUVVPVEVfTk9UX0NMT1NFRCcsIFtcbiAgICAgICAgICAgICdRdW90ZSBOb3QgQ2xvc2VkOicsXG4gICAgICAgICAgICBgdGhlIHBhcnNpbmcgaXMgZmluaXNoZWQgd2l0aCBhbiBvcGVuaW5nIHF1b3RlIGF0IGxpbmUgJHt0aGlzLmluZm8ubGluZXN9YCxcbiAgICAgICAgICBdLCB0aGlzLm9wdGlvbnMsIHRoaXMuX19pbmZvRmllbGQoKSlcbiAgICAgICAgKVxuICAgICAgICBpZihlcnIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGVyclxuICAgICAgfWVsc2V7XG4gICAgICAgIC8vIFNraXAgbGFzdCBsaW5lIGlmIGl0IGhhcyBubyBjaGFyYWN0ZXJzXG4gICAgICAgIGlmKHRoaXMuc3RhdGUud2FzUXVvdGluZyA9PT0gdHJ1ZSB8fCB0aGlzLnN0YXRlLnJlY29yZC5sZW5ndGggIT09IDAgfHwgdGhpcy5zdGF0ZS5maWVsZC5sZW5ndGggIT09IDApe1xuICAgICAgICAgIHRoaXMuaW5mby5ieXRlcyA9IHRoaXMuc3RhdGUuYnVmQnl0ZXNTdGFydCArIHBvcztcbiAgICAgICAgICBjb25zdCBlcnJGaWVsZCA9IHRoaXMuX19vbkZpZWxkKClcbiAgICAgICAgICBpZihlcnJGaWVsZCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyRmllbGRcbiAgICAgICAgICBjb25zdCBlcnJSZWNvcmQgPSB0aGlzLl9fb25SZWNvcmQoKVxuICAgICAgICAgIGlmKGVyclJlY29yZCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZXJyUmVjb3JkXG4gICAgICAgIH1lbHNlIGlmKHRoaXMuc3RhdGUud2FzUm93RGVsaW1pdGVyID09PSB0cnVlKXtcbiAgICAgICAgICB0aGlzLmluZm8uZW1wdHlfbGluZXMrK1xuICAgICAgICB9ZWxzZSBpZih0aGlzLnN0YXRlLmNvbW1lbnRpbmcgPT09IHRydWUpe1xuICAgICAgICAgIHRoaXMuaW5mby5jb21tZW50X2xpbmVzKytcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgdGhpcy5zdGF0ZS5idWZCeXRlc1N0YXJ0ICs9IHBvc1xuICAgICAgdGhpcy5zdGF0ZS5wcmV2aW91c0J1ZiA9IGJ1Zi5zbGljZShwb3MpXG4gICAgfVxuICAgIGlmKHRoaXMuc3RhdGUud2FzUm93RGVsaW1pdGVyID09PSB0cnVlKXtcbiAgICAgIHRoaXMuaW5mby5saW5lcysrXG4gICAgICB0aGlzLnN0YXRlLndhc1Jvd0RlbGltaXRlciA9IGZhbHNlXG4gICAgfVxuICB9XG4gIF9fb25SZWNvcmQoKXtcbiAgICBjb25zdCB7Y29sdW1ucywgY29sdW1uc19kdXBsaWNhdGVzX3RvX2FycmF5LCBlbmNvZGluZywgaW5mbywgZnJvbSwgcmVsYXhfY29sdW1uX2NvdW50LCByZWxheF9jb2x1bW5fY291bnRfbGVzcywgcmVsYXhfY29sdW1uX2NvdW50X21vcmUsIHJhdywgc2tpcF9saW5lc193aXRoX2VtcHR5X3ZhbHVlc30gPSB0aGlzLm9wdGlvbnNcbiAgICBjb25zdCB7ZW5hYmxlZCwgcmVjb3JkfSA9IHRoaXMuc3RhdGVcbiAgICBpZihlbmFibGVkID09PSBmYWxzZSl7XG4gICAgICByZXR1cm4gdGhpcy5fX3Jlc2V0UmVjb3JkKClcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgZmlyc3QgbGluZSBpbnRvIGNvbHVtbiBuYW1lc1xuICAgIGNvbnN0IHJlY29yZExlbmd0aCA9IHJlY29yZC5sZW5ndGhcbiAgICBpZihjb2x1bW5zID09PSB0cnVlKXtcbiAgICAgIGlmKHNraXBfbGluZXNfd2l0aF9lbXB0eV92YWx1ZXMgPT09IHRydWUgJiYgaXNSZWNvcmRFbXB0eShyZWNvcmQpKXtcbiAgICAgICAgdGhpcy5fX3Jlc2V0UmVjb3JkKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX2ZpcnN0TGluZVRvQ29sdW1ucyhyZWNvcmQpXG4gICAgfVxuICAgIGlmKGNvbHVtbnMgPT09IGZhbHNlICYmIHRoaXMuaW5mby5yZWNvcmRzID09PSAwKXtcbiAgICAgIHRoaXMuc3RhdGUuZXhwZWN0ZWRSZWNvcmRMZW5ndGggPSByZWNvcmRMZW5ndGhcbiAgICB9XG4gICAgaWYocmVjb3JkTGVuZ3RoICE9PSB0aGlzLnN0YXRlLmV4cGVjdGVkUmVjb3JkTGVuZ3RoKXtcbiAgICAgIGNvbnN0IGVyciA9IGNvbHVtbnMgPT09IGZhbHNlID9cbiAgICAgICAgLy8gVG9kbzogcmVuYW1lIENTVl9JTkNPTlNJU1RFTlRfUkVDT1JEX0xFTkdUSCB0b1xuICAgICAgICAvLyBDU1ZfUkVDT1JEX0lOQ09OU0lTVEVOVF9GSUVMRFNfTEVOR1RIXG4gICAgICAgIG5ldyBDc3ZFcnJvcignQ1NWX0lOQ09OU0lTVEVOVF9SRUNPUkRfTEVOR1RIJywgW1xuICAgICAgICAgICdJbnZhbGlkIFJlY29yZCBMZW5ndGg6JyxcbiAgICAgICAgICBgZXhwZWN0ICR7dGhpcy5zdGF0ZS5leHBlY3RlZFJlY29yZExlbmd0aH0sYCxcbiAgICAgICAgICBgZ290ICR7cmVjb3JkTGVuZ3RofSBvbiBsaW5lICR7dGhpcy5pbmZvLmxpbmVzfWAsXG4gICAgICAgIF0sIHRoaXMub3B0aW9ucywgdGhpcy5fX2luZm9GaWVsZCgpLCB7XG4gICAgICAgICAgcmVjb3JkOiByZWNvcmQsXG4gICAgICAgIH0pXG4gICAgICA6XG4gICAgICAgIC8vIFRvZG86IHJlbmFtZSBDU1ZfUkVDT1JEX0RPTlRfTUFUQ0hfQ09MVU1OU19MRU5HVEggdG9cbiAgICAgICAgLy8gQ1NWX1JFQ09SRF9JTkNPTlNJU1RFTlRfQ09MVU1OU1xuICAgICAgICBuZXcgQ3N2RXJyb3IoJ0NTVl9SRUNPUkRfRE9OVF9NQVRDSF9DT0xVTU5TX0xFTkdUSCcsIFtcbiAgICAgICAgICAnSW52YWxpZCBSZWNvcmQgTGVuZ3RoOicsXG4gICAgICAgICAgYGNvbHVtbnMgbGVuZ3RoIGlzICR7Y29sdW1ucy5sZW5ndGh9LGAsIC8vIHJlbmFtZSBjb2x1bW5zXG4gICAgICAgICAgYGdvdCAke3JlY29yZExlbmd0aH0gb24gbGluZSAke3RoaXMuaW5mby5saW5lc31gLFxuICAgICAgICBdLCB0aGlzLm9wdGlvbnMsIHRoaXMuX19pbmZvRmllbGQoKSwge1xuICAgICAgICAgIHJlY29yZDogcmVjb3JkLFxuICAgICAgICB9KVxuICAgICAgaWYocmVsYXhfY29sdW1uX2NvdW50ID09PSB0cnVlIHx8XG4gICAgICAgIChyZWxheF9jb2x1bW5fY291bnRfbGVzcyA9PT0gdHJ1ZSAmJiByZWNvcmRMZW5ndGggPCB0aGlzLnN0YXRlLmV4cGVjdGVkUmVjb3JkTGVuZ3RoKSB8fFxuICAgICAgICAocmVsYXhfY29sdW1uX2NvdW50X21vcmUgPT09IHRydWUgJiYgcmVjb3JkTGVuZ3RoID4gdGhpcy5zdGF0ZS5leHBlY3RlZFJlY29yZExlbmd0aCkgKXtcbiAgICAgICAgdGhpcy5pbmZvLmludmFsaWRfZmllbGRfbGVuZ3RoKytcbiAgICAgICAgdGhpcy5zdGF0ZS5lcnJvciA9IGVyclxuICAgICAgLy8gRXJyb3IgaXMgdW5kZWZpbmVkIHdpdGggc2tpcF9saW5lc193aXRoX2Vycm9yXG4gICAgICB9ZWxzZXtcbiAgICAgICAgY29uc3QgZmluYWxFcnIgPSB0aGlzLl9fZXJyb3IoZXJyKVxuICAgICAgICBpZihmaW5hbEVycikgcmV0dXJuIGZpbmFsRXJyXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHNraXBfbGluZXNfd2l0aF9lbXB0eV92YWx1ZXMgPT09IHRydWUgJiYgaXNSZWNvcmRFbXB0eShyZWNvcmQpKXtcbiAgICAgIHRoaXMuX19yZXNldFJlY29yZCgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYodGhpcy5zdGF0ZS5yZWNvcmRIYXNFcnJvciA9PT0gdHJ1ZSl7XG4gICAgICB0aGlzLl9fcmVzZXRSZWNvcmQoKVxuICAgICAgdGhpcy5zdGF0ZS5yZWNvcmRIYXNFcnJvciA9IGZhbHNlXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5pbmZvLnJlY29yZHMrK1xuICAgIGlmKGZyb20gPT09IDEgfHwgdGhpcy5pbmZvLnJlY29yZHMgPj0gZnJvbSl7XG4gICAgICAvLyBXaXRoIGNvbHVtbnMsIHJlY29yZHMgYXJlIG9iamVjdFxuICAgICAgaWYoY29sdW1ucyAhPT0gZmFsc2Upe1xuICAgICAgICBjb25zdCBvYmogPSB7fVxuICAgICAgICAvLyBUcmFuc2Zvcm0gcmVjb3JkIGFycmF5IHRvIGFuIG9iamVjdFxuICAgICAgICBmb3IobGV0IGkgPSAwLCBsID0gcmVjb3JkLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG4gICAgICAgICAgaWYoY29sdW1uc1tpXSA9PT0gdW5kZWZpbmVkIHx8IGNvbHVtbnNbaV0uZGlzYWJsZWQpIGNvbnRpbnVlXG4gICAgICAgICAgLy8gVHVybiBkdXBsaWNhdGUgY29sdW1ucyBpbnRvIGFuIGFycmF5XG4gICAgICAgICAgaWYgKGNvbHVtbnNfZHVwbGljYXRlc190b19hcnJheSA9PT0gdHJ1ZSAmJiBvYmpbY29sdW1uc1tpXS5uYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpbY29sdW1uc1tpXS5uYW1lXSkpIHtcbiAgICAgICAgICAgICAgb2JqW2NvbHVtbnNbaV0ubmFtZV0gPSBvYmpbY29sdW1uc1tpXS5uYW1lXS5jb25jYXQocmVjb3JkW2ldKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2JqW2NvbHVtbnNbaV0ubmFtZV0gPSBbb2JqW2NvbHVtbnNbaV0ubmFtZV0sIHJlY29yZFtpXV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW2NvbHVtbnNbaV0ubmFtZV0gPSByZWNvcmRbaV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge29iam5hbWV9ID0gdGhpcy5vcHRpb25zXG4gICAgICAgIC8vIFdpdGhvdXQgb2JqbmFtZSAoZGVmYXVsdClcbiAgICAgICAgaWYob2JqbmFtZSA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICBpZihyYXcgPT09IHRydWUgfHwgaW5mbyA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fcHVzaChPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICB7cmVjb3JkOiBvYmp9LFxuICAgICAgICAgICAgICAocmF3ID09PSB0cnVlID8ge3JhdzogdGhpcy5zdGF0ZS5yYXdCdWZmZXIudG9TdHJpbmcoZW5jb2RpbmcpfToge30pLFxuICAgICAgICAgICAgICAoaW5mbyA9PT0gdHJ1ZSA/IHtpbmZvOiB0aGlzLl9faW5mb1JlY29yZCgpfToge30pXG4gICAgICAgICAgICApKVxuICAgICAgICAgICAgaWYoZXJyKXtcbiAgICAgICAgICAgICAgcmV0dXJuIGVyclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY29uc3QgZXJyID0gdGhpcy5fX3B1c2gob2JqKVxuICAgICAgICAgICAgaWYoZXJyKXtcbiAgICAgICAgICAgICAgcmV0dXJuIGVyclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gV2l0aCBvYmpuYW1lIChkZWZhdWx0KVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBpZihyYXcgPT09IHRydWUgfHwgaW5mbyA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9fcHVzaChPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICB7cmVjb3JkOiBbb2JqW29iam5hbWVdLCBvYmpdfSxcbiAgICAgICAgICAgICAgcmF3ID09PSB0cnVlID8ge3JhdzogdGhpcy5zdGF0ZS5yYXdCdWZmZXIudG9TdHJpbmcoZW5jb2RpbmcpfToge30sXG4gICAgICAgICAgICAgIGluZm8gPT09IHRydWUgPyB7aW5mbzogdGhpcy5fX2luZm9SZWNvcmQoKX06IHt9XG4gICAgICAgICAgICApKVxuICAgICAgICAgICAgaWYoZXJyKXtcbiAgICAgICAgICAgICAgcmV0dXJuIGVyclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY29uc3QgZXJyID0gdGhpcy5fX3B1c2goW29ialtvYmpuYW1lXSwgb2JqXSlcbiAgICAgICAgICAgIGlmKGVycil7XG4gICAgICAgICAgICAgIHJldHVybiBlcnJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIC8vIFdpdGhvdXQgY29sdW1ucywgcmVjb3JkcyBhcmUgYXJyYXlcbiAgICAgIH1lbHNle1xuICAgICAgICBpZihyYXcgPT09IHRydWUgfHwgaW5mbyA9PT0gdHJ1ZSl7XG4gICAgICAgICAgY29uc3QgZXJyID0gdGhpcy5fX3B1c2goT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHtyZWNvcmQ6IHJlY29yZH0sXG4gICAgICAgICAgICByYXcgPT09IHRydWUgPyB7cmF3OiB0aGlzLnN0YXRlLnJhd0J1ZmZlci50b1N0cmluZyhlbmNvZGluZyl9OiB7fSxcbiAgICAgICAgICAgIGluZm8gPT09IHRydWUgPyB7aW5mbzogdGhpcy5fX2luZm9SZWNvcmQoKX06IHt9XG4gICAgICAgICAgKSlcbiAgICAgICAgICBpZihlcnIpe1xuICAgICAgICAgICAgcmV0dXJuIGVyclxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgY29uc3QgZXJyID0gdGhpcy5fX3B1c2gocmVjb3JkKVxuICAgICAgICAgIGlmKGVycil7XG4gICAgICAgICAgICByZXR1cm4gZXJyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX19yZXNldFJlY29yZCgpXG4gIH1cbiAgX19maXJzdExpbmVUb0NvbHVtbnMocmVjb3JkKXtcbiAgICBjb25zdCB7Zmlyc3RMaW5lVG9IZWFkZXJzfSA9IHRoaXMuc3RhdGVcbiAgICB0cnl7XG4gICAgICBjb25zdCBoZWFkZXJzID0gZmlyc3RMaW5lVG9IZWFkZXJzID09PSB1bmRlZmluZWQgPyByZWNvcmQgOiBmaXJzdExpbmVUb0hlYWRlcnMuY2FsbChudWxsLCByZWNvcmQpXG4gICAgICBpZighQXJyYXkuaXNBcnJheShoZWFkZXJzKSl7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZXJyb3IoXG4gICAgICAgICAgbmV3IENzdkVycm9yKCdDU1ZfSU5WQUxJRF9DT0xVTU5fTUFQUElORycsIFtcbiAgICAgICAgICAgICdJbnZhbGlkIENvbHVtbiBNYXBwaW5nOicsXG4gICAgICAgICAgICAnZXhwZWN0IGFuIGFycmF5IGZyb20gY29sdW1uIGZ1bmN0aW9uLCcsXG4gICAgICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkoaGVhZGVycyl9YFxuICAgICAgICAgIF0sIHRoaXMub3B0aW9ucywgdGhpcy5fX2luZm9GaWVsZCgpLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRIZWFkZXJzID0gbm9ybWFsaXplQ29sdW1uc0FycmF5KGhlYWRlcnMpXG4gICAgICB0aGlzLnN0YXRlLmV4cGVjdGVkUmVjb3JkTGVuZ3RoID0gbm9ybWFsaXplZEhlYWRlcnMubGVuZ3RoXG4gICAgICB0aGlzLm9wdGlvbnMuY29sdW1ucyA9IG5vcm1hbGl6ZWRIZWFkZXJzXG4gICAgICB0aGlzLl9fcmVzZXRSZWNvcmQoKVxuICAgICAgcmV0dXJuXG4gICAgfWNhdGNoKGVycil7XG4gICAgICByZXR1cm4gZXJyXG4gICAgfVxuICB9XG4gIF9fcmVzZXRSZWNvcmQoKXtcbiAgICBpZih0aGlzLm9wdGlvbnMucmF3ID09PSB0cnVlKXtcbiAgICAgIHRoaXMuc3RhdGUucmF3QnVmZmVyLnJlc2V0KClcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5lcnJvciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuc3RhdGUucmVjb3JkID0gW11cbiAgICB0aGlzLnN0YXRlLnJlY29yZF9sZW5ndGggPSAwXG4gIH1cbiAgX19vbkZpZWxkKCl7XG4gICAgY29uc3Qge2Nhc3QsIGVuY29kaW5nLCBydHJpbSwgbWF4X3JlY29yZF9zaXplfSA9IHRoaXMub3B0aW9uc1xuICAgIGNvbnN0IHtlbmFibGVkLCB3YXNRdW90aW5nfSA9IHRoaXMuc3RhdGVcbiAgICAvLyBTaG9ydCBjaXJjdWl0IGZvciB0aGUgZnJvbV9saW5lIG9wdGlvbnNcbiAgICBpZihlbmFibGVkID09PSBmYWxzZSl7XG4gICAgICByZXR1cm4gdGhpcy5fX3Jlc2V0RmllbGQoKVxuICAgIH1cbiAgICBsZXQgZmllbGQgPSB0aGlzLnN0YXRlLmZpZWxkLnRvU3RyaW5nKGVuY29kaW5nKVxuICAgIGlmKHJ0cmltID09PSB0cnVlICYmIHdhc1F1b3RpbmcgPT09IGZhbHNlKXtcbiAgICAgIGZpZWxkID0gZmllbGQudHJpbVJpZ2h0KClcbiAgICB9XG4gICAgaWYoY2FzdCA9PT0gdHJ1ZSl7XG4gICAgICBjb25zdCBbZXJyLCBmXSA9IHRoaXMuX19jYXN0KGZpZWxkKVxuICAgICAgaWYoZXJyICE9PSB1bmRlZmluZWQpIHJldHVybiBlcnJcbiAgICAgIGZpZWxkID0gZlxuICAgIH1cbiAgICB0aGlzLnN0YXRlLnJlY29yZC5wdXNoKGZpZWxkKVxuICAgIC8vIEluY3JlbWVudCByZWNvcmQgbGVuZ3RoIGlmIHJlY29yZCBzaXplIG11c3Qgbm90IGV4Y2VlZCBhIGxpbWl0XG4gICAgaWYobWF4X3JlY29yZF9zaXplICE9PSAwICYmIHR5cGVvZiBmaWVsZCA9PT0gJ3N0cmluZycpe1xuICAgICAgdGhpcy5zdGF0ZS5yZWNvcmRfbGVuZ3RoICs9IGZpZWxkLmxlbmd0aFxuICAgIH1cbiAgICB0aGlzLl9fcmVzZXRGaWVsZCgpXG4gIH1cbiAgX19yZXNldEZpZWxkKCl7XG4gICAgdGhpcy5zdGF0ZS5maWVsZC5yZXNldCgpXG4gICAgdGhpcy5zdGF0ZS53YXNRdW90aW5nID0gZmFsc2VcbiAgfVxuICBfX3B1c2gocmVjb3JkKXtcbiAgICBjb25zdCB7b25fcmVjb3JkfSA9IHRoaXMub3B0aW9uc1xuICAgIGlmKG9uX3JlY29yZCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgIGNvbnN0IGluZm8gPSB0aGlzLl9faW5mb1JlY29yZCgpXG4gICAgICB0cnl7XG4gICAgICAgIHJlY29yZCA9IG9uX3JlY29yZC5jYWxsKG51bGwsIHJlY29yZCwgaW5mbylcbiAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICByZXR1cm4gZXJyXG4gICAgICB9XG4gICAgICBpZihyZWNvcmQgPT09IHVuZGVmaW5lZCB8fCByZWNvcmQgPT09IG51bGwpeyByZXR1cm4gfVxuICAgIH1cbiAgICB0aGlzLnB1c2gocmVjb3JkKVxuICB9XG4gIC8vIFJldHVybiBhIHR1cGxlIHdpdGggdGhlIGVycm9yIGFuZCB0aGUgY2FzdGVkIHZhbHVlXG4gIF9fY2FzdChmaWVsZCl7XG4gICAgY29uc3Qge2NvbHVtbnMsIHJlbGF4X2NvbHVtbl9jb3VudH0gPSB0aGlzLm9wdGlvbnNcbiAgICBjb25zdCBpc0NvbHVtbnMgPSBBcnJheS5pc0FycmF5KGNvbHVtbnMpXG4gICAgLy8gRG9udCBsb29zZSB0aW1lIGNhbGxpbmcgY2FzdFxuICAgIC8vIGJlY2F1c2UgdGhlIGZpbmFsIHJlY29yZCBpcyBhbiBvYmplY3RcbiAgICAvLyBhbmQgdGhpcyBmaWVsZCBjYW4ndCBiZSBhc3NvY2lhdGVkIHRvIGEga2V5IHByZXNlbnQgaW4gY29sdW1uc1xuICAgIGlmKCBpc0NvbHVtbnMgPT09IHRydWUgJiYgcmVsYXhfY29sdW1uX2NvdW50ICYmIHRoaXMub3B0aW9ucy5jb2x1bW5zLmxlbmd0aCA8PSB0aGlzLnN0YXRlLnJlY29yZC5sZW5ndGggKXtcbiAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gICAgfVxuICAgIGlmKHRoaXMuc3RhdGUuY2FzdEZpZWxkICE9PSBudWxsKXtcbiAgICAgIHRyeXtcbiAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuX19pbmZvRmllbGQoKVxuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5zdGF0ZS5jYXN0RmllbGQuY2FsbChudWxsLCBmaWVsZCwgaW5mbyldXG4gICAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgcmV0dXJuIFtlcnJdXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHRoaXMuX19pc0Zsb2F0KGZpZWxkKSl7XG4gICAgICByZXR1cm4gW3VuZGVmaW5lZCwgcGFyc2VGbG9hdChmaWVsZCldXG4gICAgfWVsc2UgaWYodGhpcy5vcHRpb25zLmNhc3RfZGF0ZSAhPT0gZmFsc2Upe1xuICAgICAgY29uc3QgaW5mbyA9IHRoaXMuX19pbmZvRmllbGQoKVxuICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHRoaXMub3B0aW9ucy5jYXN0X2RhdGUuY2FsbChudWxsLCBmaWVsZCwgaW5mbyldXG4gICAgfVxuICAgIHJldHVybiBbdW5kZWZpbmVkLCBmaWVsZF1cbiAgfVxuICAvLyBIZWxwZXIgdG8gdGVzdCBpZiBhIGNoYXJhY3RlciBpcyBhIHNwYWNlIG9yIGEgbGluZSBkZWxpbWl0ZXJcbiAgX19pc0NoYXJUcmltYWJsZShjaHIpe1xuICAgIHJldHVybiBjaHIgPT09IHNwYWNlIHx8IGNociA9PT0gdGFiIHx8IGNociA9PT0gY3IgfHwgY2hyID09PSBubCB8fCBjaHIgPT09IG5wXG4gIH1cbiAgLy8gS2VlcCBpdCBpbiBjYXNlIHdlIGltcGxlbWVudCB0aGUgYGNhc3RfaW50YCBvcHRpb25cbiAgLy8gX19pc0ludCh2YWx1ZSl7XG4gIC8vICAgLy8gcmV0dXJuIE51bWJlci5pc0ludGVnZXIocGFyc2VJbnQodmFsdWUpKVxuICAvLyAgIC8vIHJldHVybiAhaXNOYU4oIHBhcnNlSW50KCBvYmogKSApO1xuICAvLyAgIHJldHVybiAvXihcXC18XFwrKT9bMS05XVswLTldKiQvLnRlc3QodmFsdWUpXG4gIC8vIH1cbiAgX19pc0Zsb2F0KHZhbHVlKXtcbiAgICByZXR1cm4gKHZhbHVlIC0gcGFyc2VGbG9hdCggdmFsdWUgKSArIDEpID49IDAgLy8gQm9ycm93ZWQgZnJvbSBqcXVlcnlcbiAgfVxuICBfX2NvbXBhcmVCeXRlcyhzb3VyY2VCdWYsIHRhcmdldEJ1ZiwgdGFyZ2V0UG9zLCBmaXJzdEJ5dGUpe1xuICAgIGlmKHNvdXJjZUJ1ZlswXSAhPT0gZmlyc3RCeXRlKSByZXR1cm4gMFxuICAgIGNvbnN0IHNvdXJjZUxlbmd0aCA9IHNvdXJjZUJ1Zi5sZW5ndGhcbiAgICBmb3IobGV0IGkgPSAxOyBpIDwgc291cmNlTGVuZ3RoOyBpKyspe1xuICAgICAgaWYoc291cmNlQnVmW2ldICE9PSB0YXJnZXRCdWZbdGFyZ2V0UG9zK2ldKSByZXR1cm4gMFxuICAgIH1cbiAgICByZXR1cm4gc291cmNlTGVuZ3RoXG4gIH1cbiAgX19uZWVkTW9yZURhdGEoaSwgYnVmTGVuLCBlbmQpe1xuICAgIGlmKGVuZCkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3Qge3F1b3RlfSA9IHRoaXMub3B0aW9uc1xuICAgIGNvbnN0IHtxdW90aW5nLCBuZWVkTW9yZURhdGFTaXplLCByZWNvcmREZWxpbWl0ZXJNYXhMZW5ndGh9ID0gdGhpcy5zdGF0ZVxuICAgIGNvbnN0IG51bU9mQ2hhckxlZnQgPSBidWZMZW4gLSBpIC0gMVxuICAgIGNvbnN0IHJlcXVpcmVkTGVuZ3RoID0gTWF0aC5tYXgoXG4gICAgICBuZWVkTW9yZURhdGFTaXplLFxuICAgICAgLy8gU2tpcCBpZiB0aGUgcmVtYWluaW5nIGJ1ZmZlciBzbWFsbGVyIHRoYW4gcmVjb3JkIGRlbGltaXRlclxuICAgICAgcmVjb3JkRGVsaW1pdGVyTWF4TGVuZ3RoLFxuICAgICAgLy8gU2tpcCBpZiB0aGUgcmVtYWluaW5nIGJ1ZmZlciBjYW4gYmUgcmVjb3JkIGRlbGltaXRlciBmb2xsb3dpbmcgdGhlIGNsb3NpbmcgcXVvdGVcbiAgICAgIC8vIDEgaXMgZm9yIHF1b3RlLmxlbmd0aFxuICAgICAgcXVvdGluZyA/IChxdW90ZS5sZW5ndGggKyByZWNvcmREZWxpbWl0ZXJNYXhMZW5ndGgpIDogMCxcbiAgICApXG4gICAgcmV0dXJuIG51bU9mQ2hhckxlZnQgPCByZXF1aXJlZExlbmd0aFxuICB9XG4gIF9faXNEZWxpbWl0ZXIoYnVmLCBwb3MsIGNocil7XG4gICAgY29uc3Qge2RlbGltaXRlciwgaWdub3JlX2xhc3RfZGVsaW1pdGVyc30gPSB0aGlzLm9wdGlvbnNcbiAgICBpZihpZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID09PSB0cnVlICYmIHRoaXMuc3RhdGUucmVjb3JkLmxlbmd0aCA9PT0gdGhpcy5vcHRpb25zLmNvbHVtbnMubGVuZ3RoIC0gMSl7XG4gICAgICByZXR1cm4gMFxuICAgIH1lbHNlIGlmKGlnbm9yZV9sYXN0X2RlbGltaXRlcnMgIT09IGZhbHNlICYmIHR5cGVvZiBpZ25vcmVfbGFzdF9kZWxpbWl0ZXJzID09PSAnbnVtYmVyJyAmJiB0aGlzLnN0YXRlLnJlY29yZC5sZW5ndGggPT09IGlnbm9yZV9sYXN0X2RlbGltaXRlcnMgLSAxKXtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIGxvb3AxOiBmb3IobGV0IGkgPSAwOyBpIDwgZGVsaW1pdGVyLmxlbmd0aDsgaSsrKXtcbiAgICAgIGNvbnN0IGRlbCA9IGRlbGltaXRlcltpXVxuICAgICAgaWYoZGVsWzBdID09PSBjaHIpe1xuICAgICAgICBmb3IobGV0IGogPSAxOyBqIDwgZGVsLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICBpZihkZWxbal0gIT09IGJ1Zltwb3Mral0pIGNvbnRpbnVlIGxvb3AxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbC5sZW5ndGhcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDBcbiAgfVxuICBfX2lzUmVjb3JkRGVsaW1pdGVyKGNociwgYnVmLCBwb3Mpe1xuICAgIGNvbnN0IHtyZWNvcmRfZGVsaW1pdGVyfSA9IHRoaXMub3B0aW9uc1xuICAgIGNvbnN0IHJlY29yZERlbGltaXRlckxlbmd0aCA9IHJlY29yZF9kZWxpbWl0ZXIubGVuZ3RoXG4gICAgbG9vcDE6IGZvcihsZXQgaSA9IDA7IGkgPCByZWNvcmREZWxpbWl0ZXJMZW5ndGg7IGkrKyl7XG4gICAgICBjb25zdCByZCA9IHJlY29yZF9kZWxpbWl0ZXJbaV1cbiAgICAgIGNvbnN0IHJkTGVuZ3RoID0gcmQubGVuZ3RoXG4gICAgICBpZihyZFswXSAhPT0gY2hyKXtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGZvcihsZXQgaiA9IDE7IGogPCByZExlbmd0aDsgaisrKXtcbiAgICAgICAgaWYocmRbal0gIT09IGJ1Zltwb3Mral0pe1xuICAgICAgICAgIGNvbnRpbnVlIGxvb3AxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZC5sZW5ndGhcbiAgICB9XG4gICAgcmV0dXJuIDBcbiAgfVxuICBfX2lzRXNjYXBlKGJ1ZiwgcG9zLCBjaHIpe1xuICAgIGNvbnN0IHtlc2NhcGV9ID0gdGhpcy5vcHRpb25zXG4gICAgaWYoZXNjYXBlID09PSBudWxsKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBsID0gZXNjYXBlLmxlbmd0aFxuICAgIGlmKGVzY2FwZVswXSA9PT0gY2hyKXtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsOyBpKyspe1xuICAgICAgICBpZihlc2NhcGVbaV0gIT09IGJ1Zltwb3MraV0pe1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBfX2lzUXVvdGUoYnVmLCBwb3Mpe1xuICAgIGNvbnN0IHtxdW90ZX0gPSB0aGlzLm9wdGlvbnNcbiAgICBpZihxdW90ZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgbCA9IHF1b3RlLmxlbmd0aFxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsOyBpKyspe1xuICAgICAgaWYocXVvdGVbaV0gIT09IGJ1Zltwb3MraV0pe1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBfX2F1dG9EaXNjb3ZlclJlY29yZERlbGltaXRlcihidWYsIHBvcyl7XG4gICAgY29uc3Qge2VuY29kaW5nfSA9IHRoaXMub3B0aW9uc1xuICAgIGNvbnN0IGNociA9IGJ1Zltwb3NdXG4gICAgaWYoY2hyID09PSBjcil7XG4gICAgICBpZihidWZbcG9zKzFdID09PSBubCl7XG4gICAgICAgIHRoaXMub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyLnB1c2goQnVmZmVyLmZyb20oJ1xcclxcbicsIGVuY29kaW5nKSlcbiAgICAgICAgdGhpcy5zdGF0ZS5yZWNvcmREZWxpbWl0ZXJNYXhMZW5ndGggPSAyXG4gICAgICAgIHJldHVybiAyXG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy5vcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIucHVzaChCdWZmZXIuZnJvbSgnXFxyJywgZW5jb2RpbmcpKVxuICAgICAgICB0aGlzLnN0YXRlLnJlY29yZERlbGltaXRlck1heExlbmd0aCA9IDFcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgICB9ZWxzZSBpZihjaHIgPT09IG5sKXtcbiAgICAgIHRoaXMub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyLnB1c2goQnVmZmVyLmZyb20oJ1xcbicsIGVuY29kaW5nKSlcbiAgICAgIHRoaXMuc3RhdGUucmVjb3JkRGVsaW1pdGVyTWF4TGVuZ3RoID0gMVxuICAgICAgcmV0dXJuIDFcbiAgICB9XG4gICAgcmV0dXJuIDBcbiAgfVxuICBfX2Vycm9yKG1zZyl7XG4gICAgY29uc3Qge3NraXBfbGluZXNfd2l0aF9lcnJvcn0gPSB0aGlzLm9wdGlvbnNcbiAgICBjb25zdCBlcnIgPSB0eXBlb2YgbXNnID09PSAnc3RyaW5nJyA/IG5ldyBFcnJvcihtc2cpIDogbXNnXG4gICAgaWYoc2tpcF9saW5lc193aXRoX2Vycm9yKXtcbiAgICAgIHRoaXMuc3RhdGUucmVjb3JkSGFzRXJyb3IgPSB0cnVlXG4gICAgICB0aGlzLmVtaXQoJ3NraXAnLCBlcnIpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gZXJyXG4gICAgfVxuICB9XG4gIF9faW5mb0RhdGFTZXQoKXtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5pbmZvLFxuICAgICAgY29sdW1uczogdGhpcy5vcHRpb25zLmNvbHVtbnNcbiAgICB9XG4gIH1cbiAgX19pbmZvUmVjb3JkKCl7XG4gICAgY29uc3Qge2NvbHVtbnN9ID0gdGhpcy5vcHRpb25zXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuX19pbmZvRGF0YVNldCgpLFxuICAgICAgZXJyb3I6IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICBoZWFkZXI6IGNvbHVtbnMgPT09IHRydWUsXG4gICAgICBpbmRleDogdGhpcy5zdGF0ZS5yZWNvcmQubGVuZ3RoLFxuICAgIH1cbiAgfVxuICBfX2luZm9GaWVsZCgpe1xuICAgIGNvbnN0IHtjb2x1bW5zfSA9IHRoaXMub3B0aW9uc1xuICAgIGNvbnN0IGlzQ29sdW1ucyA9IEFycmF5LmlzQXJyYXkoY29sdW1ucylcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5fX2luZm9SZWNvcmQoKSxcbiAgICAgIGNvbHVtbjogaXNDb2x1bW5zID09PSB0cnVlID9cbiAgICAgICAgKCBjb2x1bW5zLmxlbmd0aCA+IHRoaXMuc3RhdGUucmVjb3JkLmxlbmd0aCA/XG4gICAgICAgICAgY29sdW1uc1t0aGlzLnN0YXRlLnJlY29yZC5sZW5ndGhdLm5hbWUgOlxuICAgICAgICAgIG51bGxcbiAgICAgICAgKSA6XG4gICAgICAgIHRoaXMuc3RhdGUucmVjb3JkLmxlbmd0aCxcbiAgICAgIHF1b3Rpbmc6IHRoaXMuc3RhdGUud2FzUXVvdGluZyxcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcGFyc2UgPSBmdW5jdGlvbigpe1xuICBsZXQgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2tcbiAgZm9yKGxldCBpIGluIGFyZ3VtZW50cyl7XG4gICAgY29uc3QgYXJndW1lbnQgPSBhcmd1bWVudHNbaV1cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGFyZ3VtZW50XG4gICAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkICYmICh0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihhcmd1bWVudCkpKXtcbiAgICAgIGRhdGEgPSBhcmd1bWVudFxuICAgIH1lbHNlIGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiBpc09iamVjdChhcmd1bWVudCkpe1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50XG4gICAgfWVsc2UgaWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCAmJiB0eXBlID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRcbiAgICB9ZWxzZXtcbiAgICAgIHRocm93IG5ldyBDc3ZFcnJvcignQ1NWX0lOVkFMSURfQVJHVU1FTlQnLCBbXG4gICAgICAgICdJbnZhbGlkIGFyZ3VtZW50OicsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShhcmd1bWVudCl9IGF0IGluZGV4ICR7aX1gXG4gICAgICBdLCBvcHRpb25zIHx8IHt9KVxuICAgIH1cbiAgfVxuICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpXG4gIGlmKGNhbGxiYWNrKXtcbiAgICBjb25zdCByZWNvcmRzID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMub2JqbmFtZSA9PT0gdW5kZWZpbmVkID8gW10gOiB7fVxuICAgIHBhcnNlci5vbigncmVhZGFibGUnLCBmdW5jdGlvbigpe1xuICAgICAgbGV0IHJlY29yZFxuICAgICAgd2hpbGUoKHJlY29yZCA9IHRoaXMucmVhZCgpKSAhPT0gbnVsbCl7XG4gICAgICAgIGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm9iam5hbWUgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgcmVjb3Jkcy5wdXNoKHJlY29yZClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgcmVjb3Jkc1tyZWNvcmRbMF1dID0gcmVjb3JkWzFdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIHBhcnNlci5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgICAgY2FsbGJhY2soZXJyLCB1bmRlZmluZWQsIHBhcnNlci5fX2luZm9EYXRhU2V0KCkpXG4gICAgfSlcbiAgICBwYXJzZXIub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHJlY29yZHMsIHBhcnNlci5fX2luZm9EYXRhU2V0KCkpXG4gICAgfSlcbiAgfVxuICBpZihkYXRhICE9PSB1bmRlZmluZWQpe1xuICAgIC8vIEdpdmUgYSBjaGFuY2UgZm9yIGV2ZW50cyB0byBiZSByZWdpc3RlcmVkIGxhdGVyXG4gICAgaWYodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKXtcbiAgICAgICAgcGFyc2VyLndyaXRlKGRhdGEpXG4gICAgICAgIHBhcnNlci5lbmQoKVxuICAgICAgfSlcbiAgICB9ZWxzZXtcbiAgICAgIHBhcnNlci53cml0ZShkYXRhKVxuICAgICAgcGFyc2VyLmVuZCgpXG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJzZXJcbn1cblxuY2xhc3MgQ3N2RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIG9wdGlvbnMsIC4uLmNvbnRleHRzKSB7XG4gICAgaWYoQXJyYXkuaXNBcnJheShtZXNzYWdlKSkgbWVzc2FnZSA9IG1lc3NhZ2Uuam9pbignICcpXG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBpZihFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENzdkVycm9yKVxuICAgIH1cbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gICAgZm9yKGNvbnN0IGNvbnRleHQgb2YgY29udGV4dHMpe1xuICAgICAgZm9yKGNvbnN0IGtleSBpbiBjb250ZXh0KXtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb250ZXh0W2tleV1cbiAgICAgICAgdGhpc1trZXldID0gQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSA/IHZhbHVlLnRvU3RyaW5nKG9wdGlvbnMuZW5jb2RpbmcpIDogdmFsdWUgPT0gbnVsbCA/IHZhbHVlIDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnBhcnNlLlBhcnNlciA9IFBhcnNlclxuXG5wYXJzZS5Dc3ZFcnJvciA9IENzdkVycm9yXG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcblxuY29uc3QgdW5kZXJzY29yZSA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbihfLCBtYXRjaCl7XG4gICAgcmV0dXJuICdfJyArIG1hdGNoLnRvTG93ZXJDYXNlKClcbiAgfSlcbn1cblxuY29uc3QgaXNPYmplY3QgPSBmdW5jdGlvbihvYmope1xuICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShvYmopKVxufVxuXG5jb25zdCBpc1JlY29yZEVtcHR5ID0gZnVuY3Rpb24ocmVjb3JkKXtcbiAgcmV0dXJuIHJlY29yZC5ldmVyeSggKGZpZWxkKSA9PiBmaWVsZCA9PSBudWxsIHx8IGZpZWxkLnRvU3RyaW5nICYmIGZpZWxkLnRvU3RyaW5nKCkudHJpbSgpID09PSAnJyApXG59XG5cbmNvbnN0IG5vcm1hbGl6ZUNvbHVtbnNBcnJheSA9IGZ1bmN0aW9uKGNvbHVtbnMpe1xuICBjb25zdCBub3JtYWxpemVkQ29sdW1ucyA9IFtdO1xuICBmb3IobGV0IGkgPSAwLCBsID0gY29sdW1ucy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbaV1cbiAgICBpZihjb2x1bW4gPT09IHVuZGVmaW5lZCB8fCBjb2x1bW4gPT09IG51bGwgfHwgY29sdW1uID09PSBmYWxzZSl7XG4gICAgICBub3JtYWxpemVkQ29sdW1uc1tpXSA9IHsgZGlzYWJsZWQ6IHRydWUgfVxuICAgIH1lbHNlIGlmKHR5cGVvZiBjb2x1bW4gPT09ICdzdHJpbmcnKXtcbiAgICAgIG5vcm1hbGl6ZWRDb2x1bW5zW2ldID0geyBuYW1lOiBjb2x1bW4gfVxuICAgIH1lbHNlIGlmKGlzT2JqZWN0KGNvbHVtbikpe1xuICAgICAgaWYodHlwZW9mIGNvbHVtbi5uYW1lICE9PSAnc3RyaW5nJyl7XG4gICAgICAgIHRocm93IG5ldyBDc3ZFcnJvcignQ1NWX09QVElPTl9DT0xVTU5TX01JU1NJTkdfTkFNRScsIFtcbiAgICAgICAgICAnT3B0aW9uIGNvbHVtbnMgbWlzc2luZyBuYW1lOicsXG4gICAgICAgICAgYHByb3BlcnR5IFwibmFtZVwiIGlzIHJlcXVpcmVkIGF0IHBvc2l0aW9uICR7aX1gLFxuICAgICAgICAgICd3aGVuIGNvbHVtbiBpcyBhbiBvYmplY3QgbGl0ZXJhbCdcbiAgICAgICAgXSlcbiAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZWRDb2x1bW5zW2ldID0gY29sdW1uXG4gICAgfWVsc2V7XG4gICAgICB0aHJvdyBuZXcgQ3N2RXJyb3IoJ0NTVl9JTlZBTElEX0NPTFVNTl9ERUZJTklUSU9OJywgW1xuICAgICAgICAnSW52YWxpZCBjb2x1bW4gZGVmaW5pdGlvbjonLFxuICAgICAgICAnZXhwZWN0IGEgc3RyaW5nIG9yIGEgbGl0ZXJhbCBvYmplY3QsJyxcbiAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KGNvbHVtbil9IGF0IHBvc2l0aW9uICR7aX1gXG4gICAgICBdKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZENvbHVtbnM7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/csv-parse/lib/index.js\n");

/***/ })

};
;